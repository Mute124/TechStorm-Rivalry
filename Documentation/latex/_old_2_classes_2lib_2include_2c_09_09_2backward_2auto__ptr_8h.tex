\doxysection{C\+:/\+Users/\+HP/\+Documents/\+Git\+Hub/\+Minero-\/\+Game/\+Old/\+Classes/lib/include/c++/backward/auto\+\_\+ptr.h File Reference}
\hypertarget{_old_2_classes_2lib_2include_2c_09_09_2backward_2auto__ptr_8h}{}\label{_old_2_classes_2lib_2include_2c_09_09_2backward_2auto__ptr_8h}\index{C:/Users/HP/Documents/GitHub/Minero-\/Game/Old/Classes/lib/include/c++/backward/auto\_ptr.h@{C:/Users/HP/Documents/GitHub/Minero-\/Game/Old/Classes/lib/include/c++/backward/auto\_ptr.h}}
{\ttfamily \#include $<$bits/c++config.\+h$>$}\newline
{\ttfamily \#include $<$debug/debug.\+h$>$}\newline
Include dependency graph for auto\+\_\+ptr.\+h\+:
% FIG 0
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
namespace std \mbox{\hyperlink{_old_2_classes_2lib_2include_2c_09_09_2backward_2auto__ptr_8h_a544d74b2d5d0dd2197f5fd6f02691de0}{\+\_\+\+GLIBCXX\+\_\+\+VISIBILITY}} (default)
\end{DoxyCompactItemize}


\doxysubsection{Function Documentation}
\Hypertarget{_old_2_classes_2lib_2include_2c_09_09_2backward_2auto__ptr_8h_a544d74b2d5d0dd2197f5fd6f02691de0}\label{_old_2_classes_2lib_2include_2c_09_09_2backward_2auto__ptr_8h_a544d74b2d5d0dd2197f5fd6f02691de0} 
\index{auto\_ptr.h@{auto\_ptr.h}!\_GLIBCXX\_VISIBILITY@{\_GLIBCXX\_VISIBILITY}}
\index{\_GLIBCXX\_VISIBILITY@{\_GLIBCXX\_VISIBILITY}!auto\_ptr.h@{auto\_ptr.h}}
\doxysubsubsection{\texorpdfstring{\_GLIBCXX\_VISIBILITY()}{\_GLIBCXX\_VISIBILITY()}}
{\footnotesize\ttfamily namespace std \+\_\+\+GLIBCXX\+\_\+\+VISIBILITY (\begin{DoxyParamCaption}\item[{default}]{ }\end{DoxyParamCaption})}

A wrapper class to provide auto\+\_\+ptr with reference semantics. For example, an auto\+\_\+ptr can be assigned (or constructed from) the result of a function which returns an auto\+\_\+ptr by value.

All the auto\+\_\+ptr\+\_\+ref stuff should happen behind the scenes.

A simple smart pointer providing strict ownership semantics.

The Standard says\+: 
\begin{DoxyPre}
An {\ttfamily auto\_ptr} owns the object it holds a pointer to.  Copying
an {\ttfamily auto\_ptr} copies the pointer and transfers ownership to the
destination.  If more than one {\ttfamily auto\_ptr} owns the same object
at the same time the behavior of the program is undefined.

The uses of {\ttfamily auto\_ptr} include providing temporary
exception-\/safety for dynamically allocated memory, passing
ownership of dynamically allocated memory to a function, and
returning dynamically allocated memory from a function.  {\ttfamily auto\_ptr} does not meet the CopyConstructible and Assignable
requirements for Standard Library \href{tables.html\#65}{\texttt{ container}} elements and thus
instantiating a Standard Library container with an {\ttfamily auto\_ptr} results in undefined behavior.
\end{DoxyPre}
 Quoted from \mbox{[}20.\+4.\+5\mbox{]}/3.

Good examples of what can and cannot be done with auto\+\_\+ptr can be found in the libstdc++ testsuite.

\+\_\+\+GLIBCXX\+\_\+\+RESOLVE\+\_\+\+LIB\+\_\+\+DEFECTS
\begin{DoxyEnumerate}
\item auto\+\_\+ptr$<$$>$ conversion issues These resolutions have all been incorporated.
\end{DoxyEnumerate}

The pointed-\/to type.

An auto\+\_\+ptr is usually constructed from a raw pointer. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+p} & A pointer (defaults to NULL).\\
\hline
\end{DoxyParams}
This object now {\itshape owns} the object pointed to by {\itshape \+\_\+\+\_\+p}.

An auto\+\_\+ptr can be constructed from another auto\+\_\+ptr. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+a} & Another auto\+\_\+ptr of the same type.\\
\hline
\end{DoxyParams}
This object now {\itshape owns} the object previously owned by {\itshape \+\_\+\+\_\+a}, which has given up ownership.

An auto\+\_\+ptr can be constructed from another auto\+\_\+ptr. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+a} & Another auto\+\_\+ptr of a different but related type.\\
\hline
\end{DoxyParams}
A pointer-\/to-\/\+Tp1 must be convertible to a pointer-\/to-\/\+Tp/element\+\_\+type.

This object now {\itshape owns} the object previously owned by {\itshape \+\_\+\+\_\+a}, which has given up ownership.

auto\+\_\+ptr assignment operator. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+a} & Another auto\+\_\+ptr of the same type.\\
\hline
\end{DoxyParams}
This object now {\itshape owns} the object previously owned by {\itshape \+\_\+\+\_\+a}, which has given up ownership. The object that this one {\itshape used} to own and track has been deleted.

auto\+\_\+ptr assignment operator. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+a} & Another auto\+\_\+ptr of a different but related type.\\
\hline
\end{DoxyParams}
A pointer-\/to-\/\+Tp1 must be convertible to a pointer-\/to-\/\+Tp/element\+\_\+type.

This object now {\itshape owns} the object previously owned by {\itshape \+\_\+\+\_\+a}, which has given up ownership. The object that this one {\itshape used} to own and track has been deleted.

When the auto\+\_\+ptr goes out of scope, the object it owns is deleted. If it no longer owns anything (i.\+e., {\ttfamily \doxylink{_classes_2lib_2raylib_2src_2external_2_a_n_g_l_e_2_e_g_l_2eglext_8h_afc5e04fa58feb228bb06199ff10caa22}{get()}} is {\ttfamily NULL}), then this has no effect.

The C++ standard says there is supposed to be an empty throw specification here, but omitting it is standard conforming. Its presence can be detected only if \+\_\+\+Tp\+::\texorpdfstring{$\sim$}{\string~}\+\_\+\+Tp() throws, but this is prohibited. \mbox{[}17.\+4.\+3.\+6\mbox{]}/2

Smart pointer dereferencing.

If this auto\+\_\+ptr no longer owns anything, then this operation will crash. (For a smart pointer, {\itshape no longer owns anything} is the same as being a null pointer, and you know what happens when you dereference one of those...)

Smart pointer dereferencing.

This returns the pointer itself, which the language then will automatically cause to be dereferenced.

Bypassing the smart pointer. \begin{DoxyReturn}{Returns}
The raw pointer being managed.
\end{DoxyReturn}
You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.

\begin{DoxyNote}{Note}
This auto\+\_\+ptr still owns the memory.
\end{DoxyNote}
Bypassing the smart pointer. \begin{DoxyReturn}{Returns}
The raw pointer being managed.
\end{DoxyReturn}
You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.

\begin{DoxyNote}{Note}
This auto\+\_\+ptr no longer owns the memory. When this object goes out of scope, nothing will happen.
\end{DoxyNote}
Forcibly deletes the managed object. 
\begin{DoxyParams}{Parameters}
{\em \+\_\+\+\_\+p} & A pointer (defaults to NULL).\\
\hline
\end{DoxyParams}
This object now {\itshape owns} the object pointed to by {\itshape \+\_\+\+\_\+p}. The previous object has been deleted.

Automatic conversions

These operations are supposed to convert an auto\+\_\+ptr into and from an auto\+\_\+ptr\+\_\+ref automatically as needed. This would allow constructs such as 
\begin{DoxyCode}{0}
\DoxyCodeLine{auto\_ptr<Derived>\ \ func\_returning\_auto\_ptr(.....);}
\DoxyCodeLine{...}
\DoxyCodeLine{auto\_ptr<Base>\ ptr\ =\ func\_returning\_auto\_ptr(.....);}

\end{DoxyCode}


But it doesn\textquotesingle{}t work, and won\textquotesingle{}t be fixed. For further details see \href{http://cplusplus.github.io/LWG/lwg-closed.html\#463}{\texttt{ http\+://cplusplus.\+github.\+io/\+LWG/lwg-\/closed.\+html\#463}}Here is the call graph for this function\+:
% FIG 1
