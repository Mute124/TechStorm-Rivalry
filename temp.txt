/*
---------------------------------------------------------------------------------
| 					         Includes											|
---------------------------------------------------------------------------------
*/

#pragma once

#include "Math.h"
#include "techstorm/common.h"
#include "techstorm/core/utils/Button.h" // TODO : Can this be moved to common.h?

// Game Engine Includes
#include "techstorm/Game.h"
#include "techstorm/globalobj/Block.h"
#include "techstorm/core/obj/Gameobject.h"
#include "techstorm/core/gamescreen/MenuCamera.h"
#include "techstorm/player/Player.h"
#include "techstorm/core/rendering/Light.h"

#include "techstorm/core/threading/ThreadGroups.h"
#include "techstorm/core/ui/UIElement.h"
#include "techstorm/core/ui/UIMan.h"
#include "techstorm/ui/UIFadingMsg.h"
#include "techstorm/core/audio/FxMan.h"
#include "techstorm/globalobj/Objects.h"
#include "techstorm/console/Console.h"
#include "techstorm/core/ui/UIMenu.h"
#include "techstorm/ui/MainMenu.h"
#include "techstorm/ui/PlayerHUD.h"
#include "techstorm/economy/SystemEconomy.h"
#include "techstorm/discord/DiscordAPI.h"

#include <time.h>
#include <vector> // needed for game object list

#include <raylib.h>
#include <lua.hpp>
#include <sol/sol.hpp>

//config
#include <toml++/toml.hpp>
#include <tinyxml2.h>

#define NUM_MODELS  9               // Parametric 3d shapes to generate

namespace TechStormRivalry {
	static void mainThread() {

		// Lets the program know if the game should use HDR as the skybox
		bool useHDR = true;

		// Initialie the condition for the breathing sound.
		bool isBreathing = false;

		// Viewsway
		float swayAmount = 0.0003f; // how much should the view sway be affected.
		float swaySpeed = 0.02f; // how fast should camera sway
		float swayTimer = 0.0f; // Dont mess with this. it will fuck up the swaying.

		/*
		* Near death affect.
		* Important :
		*	THESE ARE REQUIRED FOR THE ARCH ALGORITHM TO WORK!
		*	See Math.h for the Arch algorithm explanation and uses.
		*
		* Note:
		*	Use a graphing calculator to visualize the algorithm
		*/
		float nearDeathTimer = 0.0f; // The X axis
		float amplitude = 255; // How high the Parabola goes
		float frequency = 5; // How often the arches are
		float steepness = 2.4f; // How steep the curve is, NOTE : If it is an odd number, it will not show as it only works for even times.
		float offset = 1; // Offset of the arches from x = 0
		const float scaleFactor = 25; // Scaling factor, how much the parabolas is scaled
		float nearDeathIntensity = 0.0f; // The Y Axis of the algorithm

		// Health bar fuckery
		float healthBarPositionX = 0.0f;
		float healthBarPositionY = 0.0f;
		int healthBarOffsetX = 0;
		int healthBarOffsetY = 500;

		// represents the raycasting from the player to the world.
		Ray ray;

		// Create game & load it into memory.
		Game* game = new Game();

		// Start the game and do any needed setup
		game->init();

		DiscordAPI* disc = new DiscordAPI();

		disc->initAPI();

		TechStorm::Logman::Log("Main menu ready");
		Console::ConsoleUI* console = new Console::ConsoleUI();
		MainMenu::MainMenu* menu = new MainMenu::MainMenu(game);

		menu->awakeMenu();
		menu->drawMenu(console);

		console = new Console::ConsoleUI();
		game->pushRogueElement(console);

		// Assign already setup PBR shader to model.materials[0], used by models.meshes[0]

		// Create a default block model with a length, width, and height of the value of BLOCK_SIZE.
		// This creates a cube mesh with a length, width, and height of BLOCK_SIZE and then converts it
		// to a model, loading it into memory.
		Model DefaultBlockModel = LoadModelFromMesh(
			GenMeshCube(BLOCK_SIZE, BLOCK_SIZE,
				BLOCK_SIZE)); // this is the default model used in blocksd.

		// todo : change all use instances of DefaultBlockModel to use the global default model.
		SetDefaultModel(DefaultBlockModel);

		// Construct the block object
		Block* block = new Block(Vector3Zero(), WHITE, game->pbrShader, LoadModelFromMesh(GenMeshCylinder(BLOCK_SIZE, BLOCK_SIZE, 100)));

		// Finally push it off to the object manager
		game->pushObject(block);

		// Create the player model
	// NOTE: This model is TEMPORARY! It will be deleted after a proper model is made. Refers to the
	// size of the player model. Same process as the default block model creation.
		const int Playersize = 3;
		Model PlayerModel = LoadModelFromMesh(GenMeshCube(Playersize, Playersize, Playersize));

		// Construct the player object
		Player::Player* player = new Player::Player(Vector3{ 0.0f, 2.0f, 4.0f }, PlayerModel, CAMERA_FIRST_PERSON);

		// Finally push it off to the object manager
		game->pushObject(player);

		// Skybox geometry generation step
		Mesh skyboxMesh = GenMeshCube(1.0f, 1.0f, 1.0f);

		// Skybox model loading step
		Model skybox = LoadModelFromMesh(skyboxMesh);

		// Load skybox shader and set required locations step
		// NOTE: Some locations are automatically set at shader loading
		skybox.materials[0].shader = LoadShader("resources/skybox.vs", "resources/skybox.fs");

		// since the compiler complains about the references of such, these three vars are for the
		// skybox shaders. They will be deleted after.
		static int skyboxEnvironmentMap = MATERIAL_MAP_CUBEMAP;

		// Both variables are equal to 1 if useHDR is true, otherwise 0
		static int skyboxUsesGamma = { useHDR ? 1 : 0 };
		static int skyboxIsVFlipped = { useHDR ? 1 : 0 };

		// Load the environment map
		SetShaderValue(
			skybox.materials[0].shader,
			GetShaderLocation(skybox.materials[0].shader, "environmentMap"), &skyboxEnvironmentMap,
			SHADER_UNIFORM_INT);

		// Should the shader use gamma correction
		SetShaderValue(skybox.materials[0].shader,
			GetShaderLocation(skybox.materials[0].shader, "doGamma"), &skyboxUsesGamma,
			SHADER_UNIFORM_INT);

		// Is the skybox flipped vertically
		SetShaderValue(skybox.materials[0].shader,
			GetShaderLocation(skybox.materials[0].shader, "vflipped"), &skyboxIsVFlipped,
			SHADER_UNIFORM_INT);

		// Load cubemap shader and setup required shader locations
		Shader shdrCubemap =
			LoadShader("resources/cubemap.vs", "resources/cubemap.fs");

		// set shdrCubemap's equirectangular map.
		const static int equimap = 0;
		SetShaderValue(shdrCubemap, GetShaderLocation(shdrCubemap, "equirectangularMap"), &equimap, SHADER_UNIFORM_INT);

		// Note: The filename is hardcoded here and also has a limit of 256 characters! I will be
		// dissapointed if you somehow dont know what that variable does...
		char skyboxFileName[256] = { 0 };

		// This is the panoramic texture, It is used IF useHDR is true
		Texture2D panorama = { 0 };

		if (useHDR)
		{
			TextCopy(skyboxFileName, "resources/milkyWay.hdr");

			// Load HDR panorama (sphere) texture
			panorama = LoadTexture(skyboxFileName);

			//skybox.materials[0].maps[MATERIAL_MAP_CUBEMAP].texture = GenTextureCubemap(
			//	shdrCubemap, panorama, 1024, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8);
		}
		else
		{
			// it isnt going to be used. so it can fuck off.
			UnloadTexture(panorama);

			// Load non HDR panorama (cube) texture
			Image img = LoadImage("resources/textures/space.png");

			// Set it's cubemap texture.
			skybox.materials[0].maps[MATERIAL_MAP_CUBEMAP].texture = LoadTextureCubemap(
				img, CUBEMAP_LAYOUT_AUTO_DETECT); // CUBEMAP_LAYOUT_PANORAMA

			// unload img as we dont need it anymore.
			UnloadImage(img);
		}

		TechStorm::Light sun = TechStorm::CreateLight(TechStorm::LIGHT_POINT, TechStorm::uVec3f{ 1.0f, 0.0f, 1.0f }, Vector3One(), WHITE, 4.0f, game->pbrShader);

		// The texture for the near death affect initialization
		Texture2D nearDeathTex = { 0 };

		// The image for the near death affect initialization
		Image nearDeathAffect = { 0 };

		// The color for the near death affect initialization
		TechStorm::uColor nearDeathColor = TechStorm::uColor();

		healthBarPositionX = game->winWidth + healthBarOffsetX;
		healthBarPositionY = game->winHeight + healthBarOffsetY;

		DisableCursor();

		PlayerHUD* hud = new PlayerHUD(game);

		Economy::MarketProduct tester = Economy::MarketProduct();
		tester.baseValue = 5;
		tester.supply = 100;

		Economy::Merchant* merchant = new Economy::Merchant();
		merchant->m_market[0] = tester;
		merchant->m_priceUptick = 0.25f;
		Faction::CharacterFaction fa = Faction::CharacterFaction();
		Faction::CharacterFaction fb = Faction::CharacterFaction();

		merchant->m_owner = &fb;
		fa.meetFaction(fb);
		fb.meetFaction(fa);
		SetTargetFPS(60);
		while (!WindowShouldClose())
		{
			int scroll = GetMouseWheelMove();

			disc->update();

			// Camera PRO usage example (EXPERIMENTAL)
// This new camera function allows custom movement/rotation values to be directly provided
// as input parameters, with this approach, rcamera module is internally independent of raylib inputs
			UpdateCameraPro(player->cameraComponent->getSelfCameraPointer(),
				Vector3{
					(IsKeyDown(player->controller->forward) || IsKeyDown(KEY_UP)) * player->controller->speed -      // Move forward-backward
					(IsKeyDown(player->controller->backward) || IsKeyDown(KEY_DOWN)) * player->controller->speed,
					(IsKeyDown(player->controller->right) || IsKeyDown(KEY_RIGHT)) * player->controller->speed -   // Move right-left
					(IsKeyDown(player->controller->left) || IsKeyDown(KEY_LEFT)) * player->controller->speed,
					(IsKeyDown(player->controller->jump)) * player->controller->speed -                                                 // Move up-down
					(IsKeyDown(player->controller->crouch)) * player->controller->speed
				},
				Vector3{
					GetMouseDelta().x * player->controller->mouseSensitivity,                            // Rotation: yaw
					GetMouseDelta().y * player->controller->mouseSensitivity,                            // Rotation: pitch
					player->controller->CalculateCameraTilt()                // Rotation: roll
				},

				GetMouseWheelMove() * 2.0f);                              // Move to target (zoom)

			// NOTE : This is a very basic implementation of placing an object into the world. This is
			// temporary and should be fleshed out.
			if (IsMouseButtonDown(MOUSE_BUTTON_RIGHT))
			{
				Vector3 placepos = player->cameraComponent->getTarget();
			}

			if (IsKeyPressed(KEY_ESCAPE))
			{
				// Todo, move the menuCamera to be created on game startup and then hidden. it gets
				// shown on if statement validation
				bool exitMenu = false;
				bool manualExit = false;

				MenuCamera* men_pause = new MenuCamera();
				TechStorm::ButtonR* save = new TechStorm::ButtonR("Save", 100, 100);
				TechStorm::ButtonR* Options = new TechStorm::ButtonR("Options", 100, 200);
				TechStorm::ButtonR* exitButton = new TechStorm::ButtonR("Exit to Windows", 100, 300);

				EnableCursor();
				while (!exitMenu)
				{
					game->updateUI();
					BeginDrawing();

					game->drawUI(DRAW_FINAL);

					save->draw();
					save->updateObjects();

					Options->draw();
					Options->updateObjects();

					exitButton->draw();
					exitButton->updateObjects();

					if (exitButton->IsClicked())
					{
						manualExit = true;
					}

					if (Options->IsClicked())
					{
						bool closeOptions = false;
						while (!closeOptions)
						{
							// TODO : Add options

							if (IsKeyDown(KEY_ESCAPE))
							{
								closeOptions = true;
							}
						}
					}

					EndDrawing();
					if (IsKeyPressed(KEY_ESCAPE) && exitMenu == false)
					{
						exitMenu = true;
					}
					else if (IsKeyPressed(KEY_ESCAPE) && exitMenu == true)
					{
						break;
					}

					if (manualExit)
					{
						exitMenu = true;
					}
				}

				// cleanup UnloadTexture(tex);
				delete men_pause;
				delete save;
				delete exitButton;
				if (manualExit)
				{
					TechStorm::Logman::customLog(LOG_INFO, "Exiting Game", NULL);
					exit(0);
				}
			}

			if (IsKeyPressed(KEY_E)) {
			}

			if (IsKeyDown(KEY_Y)) {
				player->damage(15);
			}

			if (IsKeyPressed(KEY_B)) {
				merchant->buy(0, 5, fa);
				TechStorm::Logman::Log(TextFormat("Supply %i, Demand %i, buy price %f, sell %f, base %i", merchant->m_market[0].supply, merchant->m_market[0].demand, merchant->m_market[0].buyPrice, merchant->m_market[0].sellPrice, merchant->m_market[0].baseValue));
			}

			if (IsKeyPressed(KEY_K)) {
				Economy::MarketPurchase purchase = merchant->sell(0, 500, fa);

				//player->m_balance += purchase.value;
				TechStorm::Logman::Log(TextFormat("Supply %i, Demand %i, buy price %f, sell %f, base %i", merchant->m_market[0].supply, merchant->m_market[0].demand, merchant->m_market[0].buyPrice, merchant->m_market[0].sellPrice, merchant->m_market[0].baseValue));
			}

			// The player's looking direction is the target of the camera. This is the direction the
			// player is looking TODO : Check relevancy.
			ray.position = player->cameraComponent->getPosition();
			ray.direction = player->cameraComponent->getTarget();

			// Sway timer is equal to swayTimer + frame delta time
			swayTimer += GetFrameTime();

			// sway the camera according to the sway algorithm.
			player->cameraComponent->setTarget(Vector3{ player->cameraComponent->getTarget().x + sin(swayTimer * swaySpeed) * swayAmount, player->cameraComponent->getTarget().y, player->cameraComponent->getTarget().z + cos(swayTimer * swaySpeed) * swayAmount });

			/*
			* 			if (player->health <= 15) {

							// equal to nearDeathTimer + frame delta time
					//nearDeathTimer += GetFrameTime();

							if (nearDeathIntensity >= 255) {
								nearDeathIntensity -= nearDeathIntensity / 2;
							}
							else if ((nearDeathIntensity > 0) && (nearDeathIntensity < 255)) {
								nearDeathIntensity += nearDeathIntensity / 2;
							}
							Image img = LoadImageFromTexture(game->renderer->getRenderTexture().texture);
							nearDeathColor = Color{ 255, 0, 0, (unsigned char)nearDeathIntensity };
							ImageColorTint(&img, nearDeathColor);
							Color* pixels = LoadImageColors(img);
							UpdateTexture(game->renderer->getRenderTexture().texture, pixels);             // Update texture with new image data
							UnloadImageColors(pixels);                  // Unload pixels data from RAM
							UpdateTexture(game->renderer->getRenderTexture().texture, pixels);
						}
			*/

			// Stashes input events for later
			PollInputEvents(); // helps for some reason?

			sun.position = player->cameraComponent->getTarget();

			TechStorm::UpdateLight(game->pbrShader, sun);

			game->updateObjects();

			game->startTexturingStep(player->cameraComponent->getSelfCameraPointer());

			game->updateUI();
			game->drawUI(DRAW_CLIPPABLE);

			//DrawTextureRec(nearDeathTex, Rectangle{ 0, 0, (float)(game->renderer->fboDimensions.x), (float)(-game->renderer->fboDimensions.y) }, TechStorm::uVec2i{ 0, 0 }, WHITE);

			game->startRenderingStep(player->cameraComponent->getSelfCamera());

			SetShaderValue(game->pbrShader, game->textureTilingLoc, &block->blockTextureTiling, SHADER_UNIFORM_VEC2);

			Vector4 carEmissiveColor = ColorNormalize(block->model.materials[0].maps[MATERIAL_MAP_EMISSION].color);
			SetShaderValue(game->pbrShader, game->emissiveColorLoc, &carEmissiveColor, SHADER_UNIFORM_VEC4);

			// How bright should the object emit it's emission color.
			float emissiveIntensity = 0.1f;
			SetShaderValue(game->pbrShader, game->emissiveIntensityLoc, &emissiveIntensity, SHADER_UNIFORM_FLOAT);

			game->renderObjects();

			game->endRenderingStep();
			game->endTexturingStep();

			game->startDrawingstep();
			game->drawUI(DRAW_FINAL);

			game->endDrawingStep();
		}

		UnloadModel(DefaultBlockModel);

		// Unload textures
		UnloadTexture(nearDeathTex);

		// Unload images
		UnloadImage(nearDeathAffect);

		// Delete temporary files.
		using namespace std;
		{
			remove("PerlinTest.png");
			remove("HMap.png");
		}

		game->assets->unloadAssets();
		game->endGame();

		delete game;
		delete block;

		//delete man;
		delete player;
	}
}
int main()
{
	try
	{
		// Run the game
		std::thread t(std::move(TechStormRivalry::mainThread));

		//scriptManager->startScriptMan(true);
		t.join();
	}
	catch (const std::exception& e)
	{
		TechStorm::Logman::Log(e.what());
	}

	return 0;
}



/***********************************************************************************
*
*   rPBR - Physically based rendering viewer for raylib
*
*   FEATURES:
*       - Load OBJ models and texture images in real-time by drag and drop.
*       - Use right mouse button to rotate lighting.
*       - Use middle mouse button to rotate and pan camera.
*       - Use interface to adjust material, textures, render and effects settings (space bar - display/hide interface).
*       - Press F1-F11 to switch between different render modes.
*       - Press F12 or use Screenshot button to capture a screenshot and save it as PNG file.
*
*   Use the following line to compile:
*
*   gcc -o $(NAME_PART).exe $(FILE_NAME) -s icon\rpbr_icon -I$(CURRENT_DIRECTORY)\external\raylib\src -L$(CURRENT_DIRECTORY)\external\raylib\release\win32
*   -L$(CURRENT_DIRECTORY)\external\raylib\src\external\glfw3\lib\win32 -L$(CURRENT_DIRECTORY)\external\raylib\src\external\openal_soft\lib\win32\ -lraylib
*   -lglfw3 -lopengl32 -lgdi32 -lopenal32 -lwinmm -std=c99 -Wl,--subsystem,windows -Wl,-allow-multiple-definition
*
*   LICENSE: zlib/libpng
*
*   rPBR is licensed under an unmodified zlib/libpng license, which is an OSI-certified,
*   BSD-like license that allows static linking with closed source software:
*
*   Copyright (c) 2017-2020 Victor Fisac
*
*   This software is provided "as-is", without any express or implied warranty. In no event
*   will the authors be held liable for any damages arising from the use of this software.
*
*   Permission is granted to anyone to use this software for any purpose, including commercial
*   applications, and to alter it and redistribute it freely, subject to the following restrictions:
*
*     1. The origin of this software must not be misrepresented; you must not claim that you
*     wrote the original software. If you use this software in a product, an acknowledgment
*     in the product documentation would be appreciated but is not required.
*
*     2. Altered source versions must be plainly marked as such, and must not be misrepresented
*     as being the original software.
*
*     3. This notice may not be removed or altered from any source distribution.
*
***********************************************************************************/
#pragma warning(disable : 4996)

//----------------------------------------------------------------------------------
// Includes
//----------------------------------------------------------------------------------
#include <math.h>                           // Required for: powf()
#include <raylib.h>
#include "raymath.h"    // Required for matrix, vectors and other math functions

#include "glad/glad.h"                  // Required for OpenGL API

#define RAYGUI_IMPLEMENTATION
#include <raygui.h>

//----------------------------------------------------------------------------------
// Defines
//----------------------------------------------------------------------------------
#define         MAX_LIGHTS                  4                                       // Max lights supported by shader
#define         MAX_MIPMAP_LEVELS           5                                       // Max number of prefilter texture mipmaps

#define         PATH_PBR_VS                 "resources/shaders/pbr.vs"              // Path to physically based rendering vertex shader
#define         PATH_PBR_FS                 "resources/shaders/pbr.fs"              // Path to physically based rendering fragment shader
#define         PATH_CUBE_VS                "resources/shaders/cubemap.vs"          // Path to equirectangular to cubemap vertex shader
#define         PATH_CUBE_FS                "resources/shaders/cubemap.fs"          // Path to equirectangular to cubemap fragment shader
#define         PATH_SKYBOX_VS              "resources/shaders/skybox.vs"           // Path to skybox vertex shader
#define         PATH_SKYBOX_FS              "resources/shaders/skybox.fs"           // Path to skybox vertex shader
#define         PATH_IRRADIANCE_FS          "resources/shaders/irradiance.fs"       // Path to irradiance (GI) calculation fragment shader
#define         PATH_PREFILTER_FS           "resources/shaders/prefilter.fs"        // Path to reflection prefilter calculation fragment shader
#define         PATH_BRDF_VS                "resources/shaders/brdf.vs"             // Path to bidirectional reflectance distribution function vertex shader
#define         PATH_BRDF_FS                "resources/shaders/brdf.fs"             // Path to bidirectional reflectance distribution function fragment shader

//----------------------------------------------------------------------------------
// Structs and enums
//----------------------------------------------------------------------------------
typedef enum {
	LIGHT_DIRECTIONAL,
	LIGHT_POINT
} LightType;

typedef struct {
	bool enabled;
	LightType type;
	Vector3 position;
	Vector3 target;
	Color color;
	int enabledLoc;
	int typeLoc;
	int posLoc;
	int targetLoc;
	int colorLoc;
} Light;

typedef struct Environment {
	Shader pbrShader;
	Shader skyShader;

	unsigned int cubemapId;
	unsigned int irradianceId;
	unsigned int prefilterId;
	unsigned int brdfId;

	int modelMatrixLoc;
	int pbrViewLoc;
	int skyViewLoc;
	int skyResolutionLoc;
} Environment;

typedef struct PropertyPBR {
	Texture2D bitmap;
	bool useBitmap;
	Color color;
	int bitmapLoc;
	int useBitmapLoc;
	int colorLoc;
} PropertyPBR;

typedef struct MaterialPBR {
	PropertyPBR albedo;
	PropertyPBR normals;
	PropertyPBR metalness;
	PropertyPBR roughness;
	PropertyPBR ao;
	PropertyPBR emission;
	PropertyPBR height;
	Environment env;
} MaterialPBR;

typedef enum TypePBR {
	PBR_ALBEDO,
	PBR_NORMALS,
	PBR_METALNESS,
	PBR_ROUGHNESS,
	PBR_AO,
	PBR_EMISSION,
	PBR_HEIGHT
} TypePBR;

//----------------------------------------------------------------------------------
// Global Variables Definition
//----------------------------------------------------------------------------------
static int lightsCount = 0;                     // Current amount of created lights

//----------------------------------------------------------------------------------
// Functions Declaration
//----------------------------------------------------------------------------------
MaterialPBR SetupMaterialPBR(Environment env, Color albedo, int metalness, int roughness);                                      // Set up PBR environment shader constant values
void SetMaterialTexturePBR(MaterialPBR* mat, TypePBR type, Texture2D texture);                                                  // Set texture to PBR material
void UnsetMaterialTexturePBR(MaterialPBR* mat, TypePBR type);                                                                   // Unset texture to PBR material and unload it from GPU
Light CreateLight(int type, Vector3 pos, Vector3 targ, Color color, Environment env);                                           // Defines a light and get locations from environment PBR shader
Environment LoadEnvironment(const char* filename, int cubemapSize, int irradianceSize, int prefilterSize, int brdfSize);        // Load an environment cubemap, irradiance, prefilter and PBR scene

int GetLightsCount(void);                                                                                                       // Get the current amount of created lights
void UpdateLightValues(Environment env, Light light);                                                                           // Send to environment PBR shader light values
void UpdateEnvironmentValues(Environment env, Camera camera, Vector2 res);                                                      // Send to environment PBR shader camera view and resolution values

void DrawModelPBR(Model model, MaterialPBR mat, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale);    // Draw a model using physically based rendering
void DrawSkybox(Environment environment, Camera camera);                                                                        // Draw a cube skybox using environment cube map
void RenderCube(void);                                                                                                          // Renders a 1x1 3D cube in NDC
void RenderQuad(void);                                                                                                          // Renders a 1x1 XY quad in NDC

void UnloadMaterialPBR(MaterialPBR mat);                                                                                        // Unload material PBR textures
void UnloadEnvironment(Environment env);                                                                                        // Unload environment loaded shaders and dynamic textures

//----------------------------------------------------------------------------------
// Functions Definition
//----------------------------------------------------------------------------------
// Set up PBR environment shader constant values
MaterialPBR SetupMaterialPBR(Environment env, Color albedo, int metalness, int roughness)
{
	MaterialPBR mat;

	// Set up material properties color
	mat.albedo.color = albedo;
	mat.normals.color = Color{ 128, 128, 255, 255 };
	mat.metalness.color = Color{ static_cast<unsigned char>(metalness), 0, 0, 0 };
	mat.roughness.color = Color{ static_cast<unsigned char>(roughness), 0, 0, 0 };
	mat.ao.color = Color{ 255, 255, 255, 255 };
	mat.emission.color = Color{ 0, 0, 0, 0 };
	mat.height.color = Color{ 0, 0, 0, 0 };

	// Set up material properties use texture state
	mat.albedo.useBitmap = false;
	mat.normals.useBitmap = false;
	mat.metalness.useBitmap = false;
	mat.roughness.useBitmap = false;
	mat.ao.useBitmap = false;
	mat.emission.useBitmap = false;
	mat.height.useBitmap = false;

	// Set up material properties textures
	mat.albedo.bitmap = Texture2D{ 0 };
	mat.normals.bitmap = Texture2D{ 0 };
	mat.metalness.bitmap = Texture2D{ 0 };
	mat.roughness.bitmap = Texture2D{ 0 };
	mat.ao.bitmap = Texture2D{ 0 };
	mat.emission.bitmap = Texture2D{ 0 };
	mat.height.bitmap = Texture2D{ 0 };

	// Set up material environment
	mat.env = env;

	// Set up PBR shader material locations
	mat.albedo.bitmapLoc = GetShaderLocation(mat.env.pbrShader, "albedo.sampler");
	mat.normals.bitmapLoc = GetShaderLocation(mat.env.pbrShader, "normals.sampler");
	mat.metalness.bitmapLoc = GetShaderLocation(mat.env.pbrShader, "metalness.sampler");
	mat.roughness.bitmapLoc = GetShaderLocation(mat.env.pbrShader, "roughness.sampler");
	mat.ao.bitmapLoc = GetShaderLocation(mat.env.pbrShader, "ao.sampler");
	mat.emission.bitmapLoc = GetShaderLocation(mat.env.pbrShader, "emission.sampler");
	mat.height.bitmapLoc = GetShaderLocation(mat.env.pbrShader, "height.sampler");

	mat.albedo.useBitmapLoc = GetShaderLocation(mat.env.pbrShader, "albedo.useSampler");
	mat.normals.useBitmapLoc = GetShaderLocation(mat.env.pbrShader, "normals.useSampler");
	mat.metalness.useBitmapLoc = GetShaderLocation(mat.env.pbrShader, "metalness.useSampler");
	mat.roughness.useBitmapLoc = GetShaderLocation(mat.env.pbrShader, "roughness.useSampler");
	mat.ao.useBitmapLoc = GetShaderLocation(mat.env.pbrShader, "ao.useSampler");
	mat.emission.useBitmapLoc = GetShaderLocation(mat.env.pbrShader, "emission.useSampler");
	mat.height.useBitmapLoc = GetShaderLocation(mat.env.pbrShader, "height.useSampler");

	mat.albedo.colorLoc = GetShaderLocation(mat.env.pbrShader, "albedo.color");
	mat.normals.colorLoc = GetShaderLocation(mat.env.pbrShader, "normals.color");
	mat.metalness.colorLoc = GetShaderLocation(mat.env.pbrShader, "metalness.color");
	mat.roughness.colorLoc = GetShaderLocation(mat.env.pbrShader, "roughness.color");
	mat.ao.colorLoc = GetShaderLocation(mat.env.pbrShader, "ao.color");
	mat.emission.colorLoc = GetShaderLocation(mat.env.pbrShader, "emission.color");
	mat.height.colorLoc = GetShaderLocation(mat.env.pbrShader, "height.color");

	// Set up PBR shader material texture units

	int a = 3;
	int b = 4;
	int c = 5;
	int d = 6;
	int e = 7;
	int f = 8;
	int g = 9;
	SetShaderValue(mat.env.pbrShader, mat.albedo.bitmapLoc, &a, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.normals.bitmapLoc, &b, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.metalness.bitmapLoc, &c, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.roughness.bitmapLoc, &d, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.ao.bitmapLoc, &e, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.emission.bitmapLoc, &f, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.height.bitmapLoc, &g, SHADER_UNIFORM_INT);

	return mat;
}

// Set texture to PBR material
void SetMaterialTexturePBR(MaterialPBR* mat, TypePBR type, Texture2D texture)
{
	switch (type)
	{
	case PBR_ALBEDO:
	{
		mat->albedo.bitmap = texture;
		mat->albedo.useBitmap = true;
	} break;
	case PBR_NORMALS:
	{
		mat->normals.bitmap = texture;
		mat->normals.useBitmap = true;
	} break;
	case PBR_METALNESS:
	{
		mat->metalness.bitmap = texture;
		mat->metalness.useBitmap = true;
	} break;
	case PBR_ROUGHNESS:
	{
		mat->roughness.bitmap = texture;
		mat->roughness.useBitmap = true;
	} break;
	case PBR_AO:
	{
		mat->ao.bitmap = texture;
		mat->ao.useBitmap = true;
	} break;
	case PBR_EMISSION:
	{
		mat->emission.bitmap = texture;
		mat->emission.useBitmap = true;
	} break;
	case PBR_HEIGHT:
	{
		mat->height.bitmap = texture;
		mat->height.useBitmap = true;
	} break;
	default: break;
	}
}

// Unset texture to PBR material and unload it from GPU
void UnsetMaterialTexturePBR(MaterialPBR* mat, TypePBR type)
{
	switch (type)
	{
	case PBR_ALBEDO:
	{
		if (mat->albedo.useBitmap)
		{
			mat->albedo.useBitmap = false;
			UnloadTexture(mat->albedo.bitmap);
			mat->albedo.bitmap = Texture2D{ 0 };
		}
	} break;
	case PBR_NORMALS:
	{
		if (mat->normals.useBitmap)
		{
			mat->normals.useBitmap = false;
			UnloadTexture(mat->normals.bitmap);
			mat->normals.bitmap = Texture2D{ 0 };
		}
	} break;
	case PBR_METALNESS:
	{
		if (mat->metalness.useBitmap)
		{
			mat->metalness.useBitmap = false;
			UnloadTexture(mat->metalness.bitmap);
			mat->metalness.bitmap = Texture2D{ 0 };
		}
	} break;
	case PBR_ROUGHNESS:
	{
		if (mat->roughness.useBitmap)
		{
			mat->roughness.useBitmap = false;
			UnloadTexture(mat->roughness.bitmap);
			mat->roughness.bitmap = Texture2D{ 0 };
		}
	} break;
	case PBR_AO:
	{
		if (mat->ao.useBitmap)
		{
			mat->ao.useBitmap = false;
			UnloadTexture(mat->ao.bitmap);
			mat->ao.bitmap = Texture2D{ 0 };
		}
	} break;
	case PBR_EMISSION:
	{
		if (mat->emission.useBitmap)
		{
			mat->emission.useBitmap = false;
			UnloadTexture(mat->emission.bitmap);
			mat->emission.bitmap = Texture2D{ 0 };
		}
	} break;
	case PBR_HEIGHT:
	{
		if (mat->height.useBitmap)
		{
			mat->height.useBitmap = false;
			UnloadTexture(mat->height.bitmap);
			mat->height.bitmap = Texture2D{ 0 };
		}
	} break;
	default: break;
	}
}

// Defines a light and get locations from environment shader
Light CreateLight(int type, Vector3 pos, Vector3 targ, Color color, Environment env)
{
	Light light = { 0 };

	if (lightsCount < MAX_LIGHTS)
	{
		light.enabled = true;
		light.type = (LightType)type;
		light.position = pos;
		light.target = targ;
		light.color = color;

		char enabledName[32] = "lights[x].enabled\0";
		char typeName[32] = "lights[x].type\0";
		char posName[32] = "lights[x].position\0";
		char targetName[32] = "lights[x].target\0";
		char colorName[32] = "lights[x].color\0";
		enabledName[7] = '0' + lightsCount;
		typeName[7] = '0' + lightsCount;
		posName[7] = '0' + lightsCount;
		targetName[7] = '0' + lightsCount;
		colorName[7] = '0' + lightsCount;

		light.enabledLoc = GetShaderLocation(env.pbrShader, enabledName);
		light.typeLoc = GetShaderLocation(env.pbrShader, typeName);
		light.posLoc = GetShaderLocation(env.pbrShader, posName);
		light.targetLoc = GetShaderLocation(env.pbrShader, targetName);
		light.colorLoc = GetShaderLocation(env.pbrShader, colorName);

		UpdateLightValues(env, light);
		lightsCount++;
	}

	return light;
}

// Load an environment cubemap, irradiance, prefilter and PBR scene
Environment LoadEnvironment(const char* filename, int cubemapSize, int irradianceSize, int prefilterSize, int brdfSize)
{
	Environment env = { 0 };

	// Load environment required shaders
	env.pbrShader = LoadShader(PATH_PBR_VS, PATH_PBR_FS);

	Shader cubeShader = LoadShader(PATH_CUBE_VS, PATH_CUBE_FS);
	Shader irradianceShader = LoadShader(PATH_SKYBOX_VS, PATH_IRRADIANCE_FS);
	Shader prefilterShader = LoadShader(PATH_SKYBOX_VS, PATH_PREFILTER_FS);
	Shader brdfShader = LoadShader(PATH_BRDF_VS, PATH_BRDF_FS);

	env.skyShader = LoadShader(PATH_SKYBOX_VS, PATH_SKYBOX_FS);

	// Get cubemap shader locations
	int cubeProjectionLoc = GetShaderLocation(cubeShader, "projection");
	int cubeViewLoc = GetShaderLocation(cubeShader, "view");

	// Get skybox shader locations
	int skyProjectionLoc = GetShaderLocation(env.skyShader, "projection");
	env.skyViewLoc = GetShaderLocation(env.skyShader, "view");
	env.skyResolutionLoc = GetShaderLocation(env.skyShader, "resolution");

	// Get irradiance shader locations
	int irradianceProjectionLoc = GetShaderLocation(irradianceShader, "projection");
	int irradianceViewLoc = GetShaderLocation(irradianceShader, "view");

	// Get prefilter shader locations
	int prefilterProjectionLoc = GetShaderLocation(prefilterShader, "projection");
	int prefilterViewLoc = GetShaderLocation(prefilterShader, "view");
	int prefilterRoughnessLoc = GetShaderLocation(prefilterShader, "roughness");

	// Set up environment shader texture units
	int imap = 0;
	int pfmap = 1;
	int brdfmap = 2;
	SetShaderValue(env.pbrShader, GetShaderLocation(env.pbrShader, "irradianceMap"), &imap, SHADER_UNIFORM_INT);
	SetShaderValue(env.pbrShader, GetShaderLocation(env.pbrShader, "prefilterMap"), &pfmap, SHADER_UNIFORM_INT);
	SetShaderValue(env.pbrShader, GetShaderLocation(env.pbrShader, "brdfLUT"), &brdfmap, SHADER_UNIFORM_INT);

	// Set up cubemap shader constant values
	SetShaderValue(cubeShader, GetShaderLocation(cubeShader, "equirectangularMap"), NULL, SHADER_UNIFORM_INT);

	// Set up irradiance shader constant values
	SetShaderValue(irradianceShader, GetShaderLocation(irradianceShader, "environmentMap"), NULL, SHADER_UNIFORM_INT);

	// Set up prefilter shader constant values
	SetShaderValue(prefilterShader, GetShaderLocation(prefilterShader, "environmentMap"), NULL, SHADER_UNIFORM_INT);

	// Set up skybox shader constant values
	SetShaderValue(env.skyShader, GetShaderLocation(env.skyShader, "environmentMap"), NULL, SHADER_UNIFORM_INT);

	// Set up depth face culling and cube map seamless
	//glDepthFunc(GL_LEQUAL);

	//glDisable(GL_CULL_FACE);
	//glEnable(GL_TEXTURE_CUBE_MAP_SEAMLESS);
	//glLineWidth(2);

	// Load HDR environment texture
	Texture2D skyTex = LoadTexture(filename);

	// Set up framebuffer for skybox
	unsigned int captureFBO, captureRBO;

	//glGenFramebuffers(1, &captureFBO);
	//glGenRenderbuffers(1, &captureRBO);
	//glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);
	//glBindRenderbuffer(GL_RENDERBUFFER, captureRBO);
	//glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, cubemapSize, cubemapSize);
	//glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, captureRBO);

	// Set up cubemap to render and attach to framebuffer
	// NOTE: faces are stored with 16 bit floating point values
	//glGenTextures(1, &env.cubemapId);
	//glBindTexture(GL_TEXTURE_CUBE_MAP, env.cubemapId);
	//for (unsigned int i = 0; i < 6; i++) glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F, cubemapSize, cubemapSize, 0, GL_RGB, GL_FLOAT, NULL);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	///glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	////glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	// Create projection (transposed) and different views for each face
	Matrix captureProjection = MatrixPerspective(90.0f, 1.0f, 0.01, 1000.0);
	MatrixTranspose(captureProjection);
	Matrix captureViews[6] = {
		MatrixLookAt(Vector3 { 0.0f, 0.0f, 0.0f },Vector3 { 1.0f, 0.0f, 0.0f }, Vector3 { 0.0f, -1.0f, 0.0f }),
		MatrixLookAt(Vector3 { 0.0f, 0.0f, 0.0f }, Vector3 { -1.0f, 0.0f, 0.0f }, Vector3 { 0.0f, -1.0f, 0.0f }),
		MatrixLookAt(Vector3 { 0.0f, 0.0f, 0.0f }, Vector3 { 0.0f, 1.0f, 0.0f }, Vector3 { 0.0f, 0.0f, 1.0f }),
		MatrixLookAt(Vector3 { 0.0f, 0.0f, 0.0f }, Vector3 { 0.0f, -1.0f, 0.0f }, Vector3 { 0.0f, 0.0f, -1.0f }),
		MatrixLookAt(Vector3 { 0.0f, 0.0f, 0.0f }, Vector3 { 0.0f, 0.0f, 1.0f }, Vector3 { 0.0f, -1.0f, 0.0f }),
		MatrixLookAt(Vector3 { 0.0f, 0.0f, 0.0f }, Vector3 { 0.0f, 0.0f, -1.0f }, Vector3 { 0.0f, -1.0f, 0.0f })
	};

	// Convert HDR equirectangular environment map to cubemap equivalent
	//glUseProgram(cubeShader.id);
	//glActiveTexture(GL_TEXTURE0);
	//glBindTexture(GL_TEXTURE_2D, skyTex.id);
	SetShaderValueMatrix(cubeShader, cubeProjectionLoc, captureProjection);

	// Note: don't forget to configure the viewport to the capture dimensions
	//glViewport(0, 0, cubemapSize, cubemapSize);
	//glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);

	for (unsigned int i = 0; i < 6; i++)
	{
		SetShaderValueMatrix(cubeShader, cubeViewLoc, captureViews[i]);

		//glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, env.cubemapId, 0);
		//glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		RenderCube();
	}

	// Unbind framebuffer and textures
	//glBindFramebuffer(GL_FRAMEBUFFER, 0);

	// Create an irradiance cubemap, and re-scale capture FBO to irradiance scale
	//glGenTextures(1, &env.irradianceId);
	//glBindTexture(GL_TEXTURE_CUBE_MAP, env.irradianceId);
	for (unsigned int i = 0; i < 6; i++) glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F, irradianceSize, irradianceSize, 0, GL_RGB, GL_FLOAT, NULL);

	// glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	//glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);
	//glBindRenderbuffer(GL_RENDERBUFFER, captureRBO);
	//glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, irradianceSize, irradianceSize);

	// Solve diffuse integral by convolution to create an irradiance cubemap
	//glUseProgram(irradianceShader.id);
	//glActiveTexture(GL_TEXTURE0);
	//glBindTexture(GL_TEXTURE_CUBE_MAP, env.cubemapId);
	SetShaderValueMatrix(irradianceShader, irradianceProjectionLoc, captureProjection);

	// Note: don't forget to configure the viewport to the capture dimensions
	//glViewport(0, 0, irradianceSize, irradianceSize);
	//glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);

	for (unsigned int i = 0; i < 6; i++)
	{
		SetShaderValueMatrix(irradianceShader, irradianceViewLoc, captureViews[i]);

		//glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, env.irradianceId, 0);
		//glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		RenderCube();
	}

	// Unbind framebuffer and textures
	//glBindFramebuffer(GL_FRAMEBUFFER, 0);

	// Create a prefiltered HDR environment map
	//glGenTextures(1, &env.prefilterId);
	//glBindTexture(GL_TEXTURE_CUBE_MAP, env.prefilterId);
	for (unsigned int i = 0; i < 6; i++) glTexImage2D(GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, GL_RGB16F, prefilterSize, prefilterSize, 0, GL_RGB, GL_FLOAT, NULL);

	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	//glTexParameteri(GL_TEXTURE_CUBE_MAP, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	// Generate mipmaps for the prefiltered HDR texture
	//glGenerateMipmap(GL_TEXTURE_CUBE_MAP);

	// Prefilter HDR and store data into mipmap levels
	//glUseProgram(prefilterShader.id);
	//glActiveTexture(GL_TEXTURE0);
	//glBindTexture(GL_TEXTURE_CUBE_MAP, env.cubemapId);
	SetShaderValueMatrix(prefilterShader, prefilterProjectionLoc, captureProjection);

	//glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);

	for (unsigned int mip = 0; mip < MAX_MIPMAP_LEVELS; mip++)
	{
		// Resize framebuffer according to mip-level size.
		unsigned int mipWidth = prefilterSize * powf(0.5f, mip);
		unsigned int mipHeight = prefilterSize * powf(0.5f, mip);

		//glBindRenderbuffer(GL_RENDERBUFFER, captureRBO);
		//glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, mipWidth, mipHeight);
		//glViewport(0, 0, mipWidth, mipHeight);

		float roughness = (float)mip / (float)(MAX_MIPMAP_LEVELS - 1);

		//glUniform1f(prefilterRoughnessLoc, roughness);

		for (unsigned int i = 0; i < 6; ++i)
		{
			SetShaderValueMatrix(prefilterShader, prefilterViewLoc, captureViews[i]);

			//glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i, env.prefilterId, mip);
			//glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
			RenderCube();
		}
	}

	// Unbind framebuffer and textures
	//glBindFramebuffer(GL_FRAMEBUFFER, 0);

	// Generate BRDF convolution texture
	//glGenTextures(1, &env.brdfId);
	//glBindTexture(GL_TEXTURE_2D, env.brdfId);
	//glTexImage2D(GL_TEXTURE_2D, 0, GL_RG16F, brdfSize, brdfSize, 0, GL_RG, GL_FLOAT, 0);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
	//glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

	// Render BRDF LUT into a quad using default FBO
	//glBindFramebuffer(GL_FRAMEBUFFER, captureFBO);
	//glBindRenderbuffer(GL_RENDERBUFFER, captureRBO);
	//glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH_COMPONENT24, brdfSize, brdfSize);
	//glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, env.brdfId, 0);

	//glViewport(0, 0, brdfSize, brdfSize);
	//glUseProgram(brdfShader.id);
	////glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	RenderQuad();

	// Unbind framebuffer and textures
	//glBindFramebuffer(GL_FRAMEBUFFER, 0);

	// Then before rendering, configure the viewport to the actual screen dimensions
	Matrix defaultProjection = MatrixPerspective(60.0, (double)GetScreenWidth() / (double)GetScreenHeight(), 0.01, 1000.0);
	MatrixTranspose(defaultProjection);
	SetShaderValueMatrix(cubeShader, cubeProjectionLoc, defaultProjection);
	SetShaderValueMatrix(env.skyShader, skyProjectionLoc, defaultProjection);
	SetShaderValueMatrix(irradianceShader, irradianceProjectionLoc, defaultProjection);
	SetShaderValueMatrix(prefilterShader, prefilterProjectionLoc, defaultProjection);
	env.pbrViewLoc = GetShaderLocation(env.pbrShader, "viewPos");
	env.modelMatrixLoc = GetShaderLocation(env.pbrShader, "mMatrix");

	// Reset viewport dimensions to default
	//glViewport(0, 0, GetScreenWidth(), GetScreenHeight());

	UnloadShader(cubeShader);
	UnloadShader(irradianceShader);
	UnloadShader(prefilterShader);
	UnloadShader(brdfShader);

	return env;
}

// Get the current amount of created lights
int GetLightsCount(void)
{
	return lightsCount;
}

// Send to environment PBR shader light values
void UpdateLightValues(Environment env, Light light)
{
	// Send to shader light enabled state and type
	SetShaderValue(env.pbrShader, light.enabledLoc, &light.enabled, SHADER_UNIFORM_INT);
	SetShaderValue(env.pbrShader, light.typeLoc, &light.type, SHADER_UNIFORM_INT);

	// Send to shader light position values
	float position[3] = { light.position.x, light.position.y, light.position.z };
	SetShaderValue(env.pbrShader, light.posLoc, position, SHADER_UNIFORM_VEC3);

	// Send to shader light target position values
	float target[3] = { light.target.x, light.target.y, light.target.z };
	SetShaderValue(env.pbrShader, light.targetLoc, target, SHADER_UNIFORM_VEC3);

	// Send to shader light color values
	float diff[4] = { (float)light.color.r / (float)255, (float)light.color.g / (float)255, (float)light.color.b / (float)255, (float)light.color.a / (float)255 };
	SetShaderValue(env.pbrShader, light.colorLoc, diff, SHADER_UNIFORM_VEC4);
}

// Send to environment PBR shader camera view and resolution values
void UpdateEnvironmentValues(Environment env, Camera camera, Vector2 res)
{
	// Send to shader camera view position
	float cameraPos[3] = { camera.position.x, camera.position.y, camera.position.z };
	SetShaderValue(env.pbrShader, env.pbrViewLoc, cameraPos, SHADER_UNIFORM_VEC3);

	// Send to shader screen resolution
	float resolution[2] = { res.x, res.y };
	SetShaderValue(env.skyShader, env.skyResolutionLoc, resolution, SHADER_UNIFORM_VEC2);
}

// Draw a model using physically based rendering
void DrawModelPBR(Model model, MaterialPBR mat, Vector3 position, Vector3 rotationAxis, float rotationAngle, Vector3 scale)
{
	// Switch to PBR shader
	glUseProgram(mat.env.pbrShader.id);

	// Set up material uniforms and other constant values
	float shaderAlbedo[3] = { (float)mat.albedo.color.r / (float)255, (float)mat.albedo.color.g / (float)255, (float)mat.albedo.color.b / (float)255 };
	SetShaderValue(mat.env.pbrShader, mat.albedo.colorLoc, shaderAlbedo, SHADER_UNIFORM_VEC3);
	float shaderNormals[3] = { (float)mat.normals.color.r / (float)255, (float)mat.normals.color.g / (float)255, (float)mat.normals.color.b / (float)255 };
	SetShaderValue(mat.env.pbrShader, mat.normals.colorLoc, shaderNormals, SHADER_UNIFORM_VEC3);
	float shaderMetalness[3] = { (float)mat.metalness.color.r / (float)255, (float)mat.metalness.color.g / (float)255, (float)mat.metalness.color.b / (float)255 };
	SetShaderValue(mat.env.pbrShader, mat.metalness.colorLoc, shaderMetalness, SHADER_UNIFORM_VEC3);
	float shaderRoughness[3] = { 1.0f - (float)mat.roughness.color.r / (float)255, 1.0f - (float)mat.roughness.color.g / (float)255, 1.0f - (float)mat.roughness.color.b / (float)255 };
	SetShaderValue(mat.env.pbrShader, mat.roughness.colorLoc, shaderRoughness, SHADER_UNIFORM_VEC3);
	float shaderAo[3] = { (float)mat.ao.color.r / (float)255, (float)mat.ao.color.g / (float)255, (float)mat.ao.color.b / (float)255 };
	SetShaderValue(mat.env.pbrShader, mat.ao.colorLoc, shaderAo, SHADER_UNIFORM_VEC3);
	float shaderEmission[3] = { (float)mat.emission.color.r / (float)255, (float)mat.emission.color.g / (float)255, (float)mat.emission.color.b / (float)255 };
	SetShaderValue(mat.env.pbrShader, mat.emission.colorLoc, shaderEmission, SHADER_UNIFORM_VEC3);
	float shaderHeight[3] = { (float)mat.height.color.r / (float)255, (float)mat.height.color.g / (float)255, (float)mat.height.color.b / (float)255 };
	SetShaderValue(mat.env.pbrShader, mat.height.colorLoc, shaderHeight, SHADER_UNIFORM_VEC3);

	// Send sampler use state to PBR shader
	SetShaderValue(mat.env.pbrShader, mat.albedo.useBitmapLoc, &mat.albedo.useBitmap, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.normals.useBitmapLoc, &mat.normals.useBitmap, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.metalness.useBitmapLoc, &mat.metalness.useBitmap, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.roughness.useBitmapLoc, &mat.roughness.useBitmap, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.ao.useBitmapLoc, &mat.ao.useBitmap, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.emission.useBitmapLoc, &mat.emission.useBitmap, SHADER_UNIFORM_INT);
	SetShaderValue(mat.env.pbrShader, mat.height.useBitmapLoc, &mat.height.useBitmap, SHADER_UNIFORM_INT);

	// Calculate and send to shader model matrix
	Matrix matScale = MatrixScale(scale.x, scale.y, scale.z);
	Matrix matRotation = MatrixRotate(rotationAxis, rotationAngle * DEG2RAD);
	Matrix matTranslation = MatrixTranslate(position.x, position.y, position.z);
	Matrix transform = MatrixMultiply(MatrixMultiply(matScale, matRotation), matTranslation);
	SetShaderValueMatrix(mat.env.pbrShader, mat.env.modelMatrixLoc, transform);

	// Enable and bind irradiance map
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_CUBE_MAP, mat.env.irradianceId);

	// Enable and bind prefiltered reflection map
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_CUBE_MAP, mat.env.prefilterId);

	// Enable and bind BRDF LUT map
	glActiveTexture(GL_TEXTURE2);
	glBindTexture(GL_TEXTURE_2D, mat.env.brdfId);

	if (mat.albedo.useBitmap)
	{
		// Enable and bind albedo map
		glActiveTexture(GL_TEXTURE3);
		glBindTexture(GL_TEXTURE_2D, mat.albedo.bitmap.id);
	}

	if (mat.normals.useBitmap)
	{
		// Enable and bind normals map
		glActiveTexture(GL_TEXTURE4);
		glBindTexture(GL_TEXTURE_2D, mat.normals.bitmap.id);
	}

	if (mat.metalness.useBitmap)
	{
		// Enable and bind metalness map
		glActiveTexture(GL_TEXTURE5);
		glBindTexture(GL_TEXTURE_2D, mat.metalness.bitmap.id);
	}

	if (mat.roughness.useBitmap)
	{
		// Enable and bind roughness map
		glActiveTexture(GL_TEXTURE6);
		glBindTexture(GL_TEXTURE_2D, mat.roughness.bitmap.id);
	}

	if (mat.ao.useBitmap)
	{
		// Enable and bind ambient occlusion map
		glActiveTexture(GL_TEXTURE7);
		glBindTexture(GL_TEXTURE_2D, mat.ao.bitmap.id);
	}

	if (mat.emission.useBitmap)
	{
		// Enable and bind emission map
		glActiveTexture(GL_TEXTURE8);
		glBindTexture(GL_TEXTURE_2D, mat.emission.bitmap.id);
	}

	if (mat.height.useBitmap)
	{
		// Enable and bind parallax height map
		glActiveTexture(GL_TEXTURE9);
		glBindTexture(GL_TEXTURE_2D, mat.height.bitmap.id);
	}

	// Draw model using PBR shader and textures maps
	DrawModelEx(model, position, rotationAxis, rotationAngle, scale, WHITE);

	// Disable and unbind irradiance map
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_CUBE_MAP, 0);

	// Disable and unbind prefiltered reflection map
	glActiveTexture(GL_TEXTURE1);
	glBindTexture(GL_TEXTURE_CUBE_MAP, 0);

	// Disable and unbind BRDF LUT map
	glActiveTexture(GL_TEXTURE2);
	glBindTexture(GL_TEXTURE_2D, 0);

	if (mat.albedo.useBitmap)
	{
		// Disable and bind albedo map
		glActiveTexture(GL_TEXTURE3);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	if (mat.normals.useBitmap)
	{
		// Disable and bind normals map
		glActiveTexture(GL_TEXTURE4);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	if (mat.metalness.useBitmap)
	{
		// Disable and bind metalness map
		glActiveTexture(GL_TEXTURE5);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	if (mat.roughness.useBitmap)
	{
		// Disable and bind roughness map
		glActiveTexture(GL_TEXTURE6);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	if (mat.ao.useBitmap)
	{
		// Disable and bind ambient occlusion map
		glActiveTexture(GL_TEXTURE7);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	if (mat.height.useBitmap)
	{
		// Disable and bind parallax height map
		glActiveTexture(GL_TEXTURE8);
		glBindTexture(GL_TEXTURE_2D, 0);
	}
}

// Draw a cube skybox using environment cube map
//void DrawSkybox(Shader sky, Texture2D cubemap, Camera camera)
void DrawSkybox(Environment env, Camera camera)
{
	// Calculate view matrix for custom shaders
	Matrix view = MatrixLookAt(camera.position, camera.target, camera.up);

	// Send to shader view matrix and bind cubemap texture
	// NOTE: Setting shader value also activates shader program but
	// that activation could change in a future... active shader manually!
	SetShaderValueMatrix(env.skyShader, env.skyViewLoc, view);

	// Skybox shader diffuse texture: cubemapId
	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_CUBE_MAP, env.cubemapId);

	// Render cube using skybox shader
	RenderCube();
}

// Renders a 1x1 3D cube in NDC
GLuint cubeVAO = 0;
GLuint cubeVBO = 0;
void RenderCube(void)
{
	// Initialize if it is not yet
	if (cubeVAO == 0)
	{
		GLfloat vertices[] = {
			-1.0f, -1.0f, -1.0f,  0.0f, 0.0f, -1.0f, 0.0f, 0.0f,
			1.0f, 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f,
			1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f,
			1.0f, 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f,
			-1.0f, -1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,
			-1.0f, 1.0f, -1.0f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f,
			-1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
			1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f,
			1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
			1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
			-1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,
			-1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
			-1.0f, 1.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
			-1.0f, 1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 1.0f,
			-1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
			-1.0f, -1.0f, -1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
			-1.0f, -1.0f, 1.0f, -1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
			-1.0f, 1.0f, 1.0f, -1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
			1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
			1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
			1.0f, 1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,
			1.0f, -1.0f, -1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
			1.0f, 1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
			1.0f, -1.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
			-1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f,
			1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 1.0f,
			1.0f, -1.0f, 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f,
			1.0f, -1.0f, 1.0f, 0.0f, -1.0f, 0.0f, 1.0f, 0.0f,
			-1.0f, -1.0f, 1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 0.0f,
			-1.0f, -1.0f, -1.0f, 0.0f, -1.0f, 0.0f, 0.0f, 1.0f,
			-1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
			1.0f, 1.0f , 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f,
			1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 1.0f,
			1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 1.0f, 0.0f,
			-1.0f, 1.0f, -1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f,
			-1.0f, 1.0f, 1.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f
		};

		// Set up cube VAO
		glGenVertexArrays(1, &cubeVAO);
		glGenBuffers(1, &cubeVBO);

		// Fill buffer
		glBindBuffer(GL_ARRAY_BUFFER, cubeVBO);
		glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);

		// Link vertex attributes
		glBindVertexArray(cubeVAO);
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)0);
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
		glEnableVertexAttribArray(2);
		glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(GLfloat), (GLvoid*)(6 * sizeof(GLfloat)));
		glBindBuffer(GL_ARRAY_BUFFER, 0);
		glBindVertexArray(0);
	}

	// Render cube
	glBindVertexArray(cubeVAO);
	glDrawArrays(GL_TRIANGLES, 0, 36);
	glBindVertexArray(0);
}

// Renders a 1x1 XY quad in NDC
GLuint quadVAO = 0;
GLuint quadVBO;
void RenderQuad(void)
{
	// Initialize if it is not yet
	if (quadVAO == 0)
	{
		GLfloat quadVertices[] = {

			// Positions        // Texture Coords
			-1.0f, 1.0f, 0.0f, 0.0f, 1.0f,
			-1.0f, -1.0f, 0.0f, 0.0f, 0.0f,
			1.0f, 1.0f, 0.0f, 1.0f, 1.0f,
			1.0f, -1.0f, 0.0f, 1.0f, 0.0f,
		};

		// Set up plane VAO
		glGenVertexArrays(1, &quadVAO);
		glGenBuffers(1, &quadVBO);
		glBindVertexArray(quadVAO);

		// Fill buffer
		glBindBuffer(GL_ARRAY_BUFFER, quadVBO);
		glBufferData(GL_ARRAY_BUFFER, sizeof(quadVertices), &quadVertices, GL_STATIC_DRAW);

		// Link vertex attributes
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), (GLvoid*)0);
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, 5 * sizeof(GLfloat), (GLvoid*)(3 * sizeof(GLfloat)));
	}

	// Render quad
	glBindVertexArray(quadVAO);
	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);
	glBindVertexArray(0);
}

// Unload material PBR textures
void UnloadMaterialPBR(MaterialPBR mat)
{
	if (mat.albedo.useBitmap) UnloadTexture(mat.albedo.bitmap);
	if (mat.normals.useBitmap) UnloadTexture(mat.normals.bitmap);
	if (mat.metalness.useBitmap) UnloadTexture(mat.metalness.bitmap);
	if (mat.roughness.useBitmap) UnloadTexture(mat.roughness.bitmap);
	if (mat.ao.useBitmap) UnloadTexture(mat.ao.bitmap);
	if (mat.emission.useBitmap) UnloadTexture(mat.emission.bitmap);
	if (mat.height.useBitmap) UnloadTexture(mat.height.bitmap);
}

// Unload environment loaded shaders and dynamic textures
void UnloadEnvironment(Environment env)
{
	// Unload used environment shaders
	UnloadShader(env.pbrShader);
	UnloadShader(env.skyShader);

	// Unload dynamic textures created in environment initialization
	glDeleteTextures(1, &env.cubemapId);
	glDeleteTextures(1, &env.irradianceId);
	glDeleteTextures(1, &env.prefilterId);
	glDeleteTextures(1, &env.brdfId);
}

//----------------------------------------------------------------------------------
// Defines
//----------------------------------------------------------------------------------
#define         WINDOW_WIDTH                1440                // Default screen width during program initialization
#define         WINDOW_HEIGHT               810                 // Default screen height during program initialization
#define         WINDOW_MIN_WIDTH            960                 // Resizable window minimum width
#define         WINDOW_MIN_HEIGHT           540                 // Resizable window minimum height

#define         KEY_NUMPAD_SUM              43                  // Decimal value of numeric pad sum button
#define         KEY_NUMPAD_SUBTRACT         45                  // Decimal value of numeric pad subtract button

#define         PATH_ICON                   "resources/textures/rpbr_icon.png"                      // Path to rPBR icon to replace default window icon
#define         PATH_MODEL                  "resources/models/cerberus.obj"                         // Path to default OBJ model to load
#define         PATH_TEXTURES_HDR           "resources/textures/hdr/pinetree.hdr"                   // Path to default HDR environment map to load
#define         PATH_TEXTURES_ALBEDO        "resources/textures/cerberus/cerberus_albedo.png"       // Path to default PBR albedo texture
#define         PATH_TEXTURES_NORMALS       "resources/textures/cerberus/cerberus_normals.png"      // Path to default PBR tangent normals texture
#define         PATH_TEXTURES_METALNESS     "resources/textures/cerberus/cerberus_metalness.png"    // Path to default PBR metalness texture
#define         PATH_TEXTURES_ROUGHNESS     "resources/textures/cerberus/cerberus_roughness.png"    // Path to default PBR roughness texture

// #define      PATH_TEXTURES_AO            "resources/textures/cerberus/cerberus_ao.png"           // Path to default PBR ambient occlusion texture (NO AVAILABLE)
// #define      PATH_TEXTURES_EMISSION      "resources/textures/cerberus/cerberus_emission.png"     // Path to default PBR emission texture  (NO AVAILABLE)
// #define      PATH_TEXTURES_HEIGHT        "resources/textures/cerberus/cerberus_height.png"       // Path to default PBR parallax height texture  (NO AVAILABLE)
#define         PATH_SHADERS_POSTFX_VS      "resources/shaders/postfx.vs"                           // Path to screen post-processing effects vertex shader
#define         PATH_SHADERS_POSTFX_FS      "resources/shaders/postfx.fs"                           // Path to screen post-processing effects fragment shader
#define         PATH_GUI_STYLE              "resources/rpbr_gui.style"                              // Path to GUI style data file

#define         MAX_TEXTURES                7                   // Max number of supported textures in a PBR material
#define         MAX_RENDER_SCALES           5                   // Max number of available render scales (RenderScale type)
#define         MAX_RENDER_MODES            11                  // Max number of render modes to switch (RenderMode type)
#define         MAX_CAMERA_TYPES            2                   // Max number of camera modes to switch (CameraType type)
#define         MAX_SUPPORTED_EXTENSIONS    5                   // Max number of supported image file extensions (JPG, PNG, BMP, TGA and PSD)
#define         MAX_SCROLL                  850                 // Max mouse wheel for interface scrolling
#define         MAX_TEXTS                   16                  // Max number of text length in array

#define         SCROLL_SPEED                50                  // Interface scrolling speed
#define         CAMERA_FOV                  60.0f               // Camera global field of view
#define         MODEL_SCALE                 1.75f               // Model scale transformation for rendering

#define         LIGHT_SPEED                 0.1f                // Light rotation input speed
#define         LIGHT_DISTANCE              3.5f                // Light distance from center of world
#define         LIGHT_HEIGHT                1.0f                // Light height from center of world
#define         LIGHT_RADIUS                0.05f               // Light gizmo drawing radius
#define         LIGHT_OFFSET                0.03f               // Light gizmo drawing radius when mouse is over

#define         CUBEMAP_SIZE                1024                // Cubemap texture size
#define         IRRADIANCE_SIZE             32                  // Irradiance map from cubemap texture size
#define         PREFILTERED_SIZE            256                 // Prefiltered HDR environment map texture size
#define         BRDF_SIZE                   512                 // BRDF LUT texture map size

#define         UI_MENU_WIDTH               225
#define         UI_MENU_BORDER              5
#define         UI_MENU_PADDING             15
#define         UI_TEXTURES_PADDING         230
#define         UI_TEXTURES_SIZE            180
#define         UI_SLIDER_WIDTH             250
#define         UI_SLIDER_HEIGHT            20
#define         UI_CHECKBOX_SIZE            20
#define         UI_BUTTON_WIDTH             120
#define         UI_BUTTON_HEIGHT            35
#define         UI_LIGHT_WIDTH              200
#define         UI_LIGHT_HEIGHT             140
#define         UI_COLOR_BACKGROUND         Color{ 5, 26, 36, 255 }
#define         UI_COLOR_SECONDARY          Color{ 245, 245, 245, 255 }
#define         UI_COLOR_PRIMARY            Color{ 234, 83, 77, 255 }
#define         UI_TEXT_SIZE_H1             30
#define         UI_TEXT_SIZE_H2             20
#define         UI_TEXT_SIZE_H3             10
#define         UI_TEXT_TEXTURES_TITLE      "Textures"
#define         UI_TEXT_DRAG_HERE           "DRAG TEXTURE HERE"
#define         UI_TEXT_MATERIAL_TITLE      "Material Properties"
#define         UI_TEXT_RENDER_TITLE        "Render Settings"
#define         UI_TEXT_RENDER_SCALE        "Render Scale"
#define         UI_TEXT_RENDER_MODE         "Render Mode"
#define         UI_TEXT_RENDER_EFFECTS      "Screen Effects"
#define         UI_TEXT_EFFECTS_TITLE       "Screen Effects"
#define         UI_TEXT_EFFECTS_FXAA        "   Antialiasing"
#define         UI_TEXT_EFFECTS_BLOOM       "   Bloom"
#define         UI_TEXT_EFFECTS_VIGNETTE    "   Vignette"
#define         UI_TEXT_EFFECTS_WIRE        "   Wireframe"
#define         UI_TEXT_DRAW_LOGO           "   Show Logo"
#define         UI_TEXT_DRAW_LIGHTS         "   Show Lights"
#define         UI_TEXT_DRAW_GRID           "   Show Grid"
#define         UI_TEXT_BUTTON_SS           "Screenshot (F12)"
#define         UI_TEXT_BUTTON_HELP         "Help (H)"
#define         UI_TEXT_BUTTON_RESET        "Reset Scene (R)"
#define         UI_TEXT_BUTTON_CLOSE_HELP   "Close Help"
#define         UI_TEXT_CONTROLS            "Controls"
#define         UI_TEXT_CREDITS             "Credits"
#define         UI_TEXT_CREDITS_VICTOR      "- Victor Fisac"
#define         UI_TEXT_CREDITS_RAMON       "[Thanks to Ramon Santamaria]"
#define         UI_TEXT_TITLE               "raylib Physically Based Renderer"
#define         UI_TEXT_CONTROLS_01         "- RMB for lighting rotation."
#define         UI_TEXT_CONTROLS_02         "- MMB (+ ALT) for camera panning (and rotation)."
#define         UI_TEXT_CONTROLS_03         "- From F1 to F11 to display each shading mode."
#define         UI_TEXT_CONTROLS_04         "- Drag and drop models (OBJ) and textures in real time."
#define         UI_TEXT_CREDITS_WEB         "Visit www.victorfisac.com for more information about the tool."
#define         UI_TEXT_DELETE              "CLICK TO DELETE TEXTURE"
#define         UI_TEXT_DISPLAY             "Use SPACE BAR to display/hide interface"
#define         UI_TEXT_LIGHT_ENABLED       "   Enabled"
#define         UI_TEXT_LIGHT_R             "R"
#define         UI_TEXT_LIGHT_G             "G"
#define         UI_TEXT_LIGHT_B             "B"

//----------------------------------------------------------------------------------
// Types and Structures Definition
//----------------------------------------------------------------------------------
typedef enum { DEF, ALBEDO, NORMALS, METALNESS, ROUGHNESS, AMBIENT_OCCLUSION, EMISSION, LIGHTING, FRESNEL, IRRADIANCE, REFLECTIVITY } RenderMode;
typedef enum { RENDER_SCALE_0_5X, RENDER_SCALE_1X, RENDER_SCALE_2X, RENDER_SCALE_4X, RENDER_SCALE_8X } RenderScale;
typedef enum { CAMERA_TYPE_FREE, CAMERA_TYPE_ORBITAL } CameraType;
typedef enum {
	LENGTH_TEXTURES_TITLE,
	LENGTH_MATERIAL_TITLE,
	LENGTH_RENDER_TITLE,
	LENGTH_RENDER_SCALE,
	LENGTH_RENDER_MODE,
	LENGTH_RENDER_EFFECTS,
	LENGTH_EFFECTS_TITLE,
	LENGTH_CONTROLS,
	LENGTH_TITLE,
	LENGTH_CREDITS,
	LENGTH_CREDITS_VICTOR,
	LENGTH_CREDITS_RAMON,
	LENGTH_CREDITS_WEB,
	LENGTH_DRAG,
	LENGTH_DELETE,
	LENGTH_DISPLAY
} LengthType;

//----------------------------------------------------------------------------------
// Global Variables Definition
//----------------------------------------------------------------------------------

int textsLength[MAX_TEXTS] = { 0 };                                     // Interface texts length array
int titlesLength[MAX_TEXTURES] = { 0 };                                 // Interface material properties lengths
const char* imageExtensions[MAX_SUPPORTED_EXTENSIONS] = {               // Supported image extensions for texture loading
	".jpg",
	".png",
	".bmp",
	".tga",
	".psd"
};
const char* textureTitles[MAX_TEXTURES] = {                             // Interface textures properties titles
	"Albedo",
	"Tangent normals",
	"Metalness",
	"Roughness",
	"Ambient occlusion",
	"Emission",
	"Parallax"
};
const char* renderScalesTitles[MAX_RENDER_SCALES] = {                   // Interface render scale settings titles
	"0.5X",
	"1.0X",
	"2.0X",
	"4.0X",
	"8.0X"
};
const char* renderModesTitles[MAX_RENDER_MODES] = {                     // Interface render modes settings titles
	"PBR (default)",
	"Albedo",
	"Tangent Normals",
	"Metalness",
	"Roughness",
	"Ambient Occlusion",
	"Emission",
	"Lighting",
	"Fresnel",
	"Irradiance (GI)",
	"Reflectivity"
};
const char* cameraTypesTitles[MAX_CAMERA_TYPES] = {                     // Interface camera type titles
	"Free Camera",
	"Orbital Camera",
};
const float renderScales[MAX_RENDER_SCALES] = {                         // Availables render scales
	0.5f,
	1.0f,
	2.0f,
	4.0f,
	8.0f
};

// Interface settings values
RenderMode renderMode = DEF;
RenderScale renderScale = RENDER_SCALE_2X;
CameraType cameraType = CAMERA_TYPE_FREE;
CameraType lastCameraType = CAMERA_TYPE_FREE;
Texture2D textures[7] = { 0 };
int selectedLight = -1;
int screenShotCount = 0;
bool resetScene = false;
bool drawGrid = false;
bool drawWire = false;
bool drawLights = true;
bool drawSkybox = true;
bool drawLogo = true;
bool drawUI = true;
bool drawHelp = false;
bool enabledFxaa = true;
bool enabledBloom = true;
bool enabledVignette = true;

// Scene resources values
Model model = { 0 };
Environment environment = { 0 };
MaterialPBR matPBR = { 0 };
Camera camera = { 0 };

//----------------------------------------------------------------------------------
// Function Declarations
//----------------------------------------------------------------------------------
void InitInterface(void);                                                                       // Initialize interface texts lengths
void DrawLight(Light light, bool over);                                                         // Draw a light gizmo based on light attributes
void DrawInterface(Vector2 size, int scrolling);                                                // Draw interface based on current window dimensions
void DrawLightInterface(Light* light);                                                          // Draw specific light settings interface
void DrawTextureMap(int id, Texture2D texture, Vector2 position);                               // Draw interface PBR texture or alternative text

//----------------------------------------------------------------------------------
// Main program
//----------------------------------------------------------------------------------
int main()
{
	// Initialization
	//------------------------------------------------------------------------------
	// Enable V-Sync and window resizable state
	SetConfigFlags(FLAG_WINDOW_RESIZABLE || FLAG_VSYNC_HINT);
	InitWindow(WINDOW_WIDTH, WINDOW_HEIGHT, "rPBR - Physically based rendering 3D model viewer");

	InitInterface();

	// Change default window icon
	Image icon = LoadImage(PATH_ICON);
	Texture2D iconTex = LoadTextureFromImage(icon);
	SetWindowIcon(icon);
	SetWindowMinSize(WINDOW_MIN_WIDTH, WINDOW_MIN_HEIGHT);

	// Define render settings states
	drawUI = true;
	bool canMoveCamera = true;
	bool overUI = false;
	int scrolling = 0;

	// Initialize lighting rotation
	int mousePosX = 0;
	int lastMousePosX = 0;
	float lightAngle = 0.0f;

	// Define the camera to look into our 3d world, its mode and model drawing position
	camera.position = Vector3{ 3.5f, 3.0f, 3.5f };
	camera.target = Vector3{ 0.0f, 0.5f, 0.0f };
	camera.up = Vector3{ 0.0f, 1.0f, 0.0f };
	camera.fovy = CAMERA_FOV;

	// Define environment attributes
	environment = Environment();
	environment = LoadEnvironment(PATH_TEXTURES_HDR, CUBEMAP_SIZE, IRRADIANCE_SIZE, PREFILTERED_SIZE, BRDF_SIZE);

	// Load external resources
	model = LoadModel(PATH_MODEL);
	matPBR = SetupMaterialPBR(environment, Color{ 255, 255, 255, 255 }, 255, 255);
#if defined(PATH_TEXTURES_ALBEDO)
	SetMaterialTexturePBR(&matPBR, PBR_ALBEDO, LoadTexture(PATH_TEXTURES_ALBEDO));
	SetTextureFilter(matPBR.albedo.bitmap, TEXTURE_FILTER_BILINEAR);
	textures[PBR_ALBEDO] = matPBR.albedo.bitmap;
#endif
#if defined(PATH_TEXTURES_NORMALS)
	SetMaterialTexturePBR(&matPBR, PBR_NORMALS, LoadTexture(PATH_TEXTURES_NORMALS));
	SetTextureFilter(matPBR.normals.bitmap, TEXTURE_FILTER_BILINEAR);
	textures[PBR_NORMALS] = matPBR.normals.bitmap;
#endif
#if defined(PATH_TEXTURES_METALNESS)
	SetMaterialTexturePBR(&matPBR, PBR_METALNESS, LoadTexture(PATH_TEXTURES_METALNESS));
	SetTextureFilter(matPBR.metalness.bitmap, TEXTURE_FILTER_BILINEAR);
	textures[PBR_METALNESS] = matPBR.metalness.bitmap;
#endif
#if defined(PATH_TEXTURES_ROUGHNESS)
	SetMaterialTexturePBR(&matPBR, PBR_ROUGHNESS, LoadTexture(PATH_TEXTURES_ROUGHNESS));
	SetTextureFilter(matPBR.roughness.bitmap, TEXTURE_FILTER_BILINEAR);
	textures[PBR_ROUGHNESS] = matPBR.roughness.bitmap;
#endif
#if defined(PATH_TEXTURES_AO)
	SetMaterialTexturePBR(&matPBR, PBR_AO, LoadTexture(PATH_TEXTURES_AO));
	SetTextureFilter(matPBR.ao.bitmap, TEXTURE_FILTER_BILINEAR);
	textures[PBR_AO] = matPBR.ao.bitmap;
#endif
#if defined(PATH_TEXTURES_EMISSION)
	SetMaterialTexturePBR(&matPBR, PBR_EMISSION, LoadTexture(PATH_TEXTURES_EMISSION));
	SetTextureFilter(matPBR.emission.bitmap, TEXTURE_FILTER_BILINEAR);
	textures[PBR_EMISSION] = matPBR.emission.bitmap;
#endif
#if defined(PATH_TEXTURES_HEIGHT)
	SetMaterialTexturePBR(&matPBR, PBR_HEIGHT, LoadTexture(PATH_TEXTURES_HEIGHT));
	SetTextureFilter(matPBR.height.bitmap, TEXTURE_FILTER_BILINEAR);
	textures[PBR_HEIGHT] = matPBR.height.bitmap;
#endif
	Shader fxShader = LoadShader(PATH_SHADERS_POSTFX_VS, PATH_SHADERS_POSTFX_FS);

	// Set up materials and lighting
	Material material = { 0 };
	material.shader = matPBR.env.pbrShader;
	model.materials[0] = material;

	// Get shaders required locations
	int shaderModeLoc = GetShaderLocation(environment.pbrShader, "renderMode");
	int fxResolutionLoc = GetShaderLocation(fxShader, "resolution");
	int enabledFxaaLoc = GetShaderLocation(fxShader, "enabledFxaa");
	int enabledBloomLoc = GetShaderLocation(fxShader, "enabledBloom");
	int enabledVignetteLoc = GetShaderLocation(fxShader, "enabledVignette");

	// Define lights attributes
	Light lights[MAX_LIGHTS] = {
		CreateLight(LIGHT_POINT, Vector3{ LIGHT_DISTANCE, LIGHT_HEIGHT, 0.0f }, Vector3 { 0.0f, 0.0f, 0.0f }, Color { 255, 0, 0, 255 }, environment),
		CreateLight(LIGHT_POINT, Vector3 { 0.0f, LIGHT_HEIGHT, LIGHT_DISTANCE }, Vector3 { 0.0f, 0.0f, 0.0f }, Color { 0, 255, 0, 255 }, environment),
		CreateLight(LIGHT_POINT, Vector3 { -LIGHT_DISTANCE, LIGHT_HEIGHT, 0.0f }, Vector3 { 0.0f, 0.0f, 0.0f }, Color { 0, 0, 255, 255 }, environment),
		CreateLight(LIGHT_DIRECTIONAL, Vector3 { 0.0f, LIGHT_HEIGHT * 2.0f, -LIGHT_DISTANCE }, Vector3 { 0.0f, 0.0f, 0.0f }, Color { 255, 0, 255, 255 }, environment)
	};
	int totalLights = GetLightsCount();

	// Create a render texture for antialiasing post-processing effect and initialize Bloom shader
	RenderTexture2D fxTarget = LoadRenderTexture(GetScreenWidth() * renderScales[renderScale], GetScreenHeight() * renderScales[renderScale]);

	// Send resolution values to post-processing shader
	float resolution[2] = { (float)GetScreenWidth() * renderScales[renderScale], (float)GetScreenHeight() * renderScales[renderScale] };
	SetShaderValue(fxShader, fxResolutionLoc, resolution, 2);
	SetShaderValue(environment.skyShader, environment.skyResolutionLoc, resolution, 2);

	// Set our game to run at 60 frames-per-second
	SetTargetFPS(60);

	//------------------------------------------------------------------------------

	// Main game loop
	while (!WindowShouldClose())
	{
		// Update
		//--------------------------------------------------------------------------
		// Update mouse collision states
		overUI = CheckCollisionPointRec(GetMousePosition(), Rectangle{ (float)GetScreenWidth() - UI_MENU_WIDTH, 0, UI_MENU_WIDTH, (float)GetScreenHeight() });

		// Check if current camera type changed since last frame
		if (lastCameraType != cameraType)
		{
			// Reset camer values and update camera mode to switch properly
			camera.position = Vector3{ 3.5f, 3.0f, 3.5f };
			camera.target = Vector3{ 0.0f, 0.5f, 0.0f };
			camera.up = Vector3{ 0.0f, 1.0f, 0.0f };
			camera.fovy = CAMERA_FOV;
			UpdateCamera(&camera, (((cameraType == CAMERA_TYPE_FREE) ? CAMERA_FREE : CAMERA_ORBITAL)));
			lastCameraType = cameraType;
		}

		// Check if scene needs to be reset
		if (resetScene || IsKeyPressed(KEY_R))
		{
			// Reset camera values and return to free mode
			camera.position = Vector3{ 3.5f, 3.0f, 3.5f };
			camera.target = Vector3{ 0.0f, 0.5f, 0.0f };
			camera.up = Vector3{ 0.0f, 1.0f, 0.0f };
			camera.fovy = CAMERA_FOV;
			cameraType = CAMERA_TYPE_FREE;
			lastCameraType = cameraType;
			UpdateCamera(&camera, (((cameraType == CAMERA_TYPE_FREE) ? CAMERA_FREE : CAMERA_ORBITAL)));

			// Reset current light angle and lights positions
			lightAngle = 0.0f;
			for (int i = 0; i < totalLights; i++)
			{
				float angle = lightAngle + 90 * i;
				lights[i].position.x = LIGHT_DISTANCE * cosf(angle * DEG2RAD);
				lights[i].position.z = LIGHT_DISTANCE * sinf(angle * DEG2RAD);

				// Send lights values to environment PBR shader
				UpdateLightValues(environment, lights[i]);
			}

			// Reset scene reset state
			resetScene = false;
		}

		// Check for display UI switch states
		if (IsKeyPressed(KEY_SPACE))
		{
			// Update current draw interface state
			drawUI = !drawUI;

			// Reset current selected light id
			if (selectedLight != -1) selectedLight = -1;
		}

		// Check for display help UI shortcut input
		if (IsKeyPressed(KEY_H))
		{
			// Update current draw help interface state
			drawHelp = true;

			// Reset current selected light
			if (selectedLight != -1) selectedLight = -1;
		}

		// Check for render mode shortcut inputs
		if (IsKeyPressed(KEY_F1)) renderMode = (RenderMode)DEF;
		else if (IsKeyPressed(KEY_F2)) renderMode = ALBEDO;
		else if (IsKeyPressed(KEY_F3)) renderMode = NORMALS;
		else if (IsKeyPressed(KEY_F4)) renderMode = METALNESS;
		else if (IsKeyPressed(KEY_F5)) renderMode = ROUGHNESS;
		else if (IsKeyPressed(KEY_F6)) renderMode = AMBIENT_OCCLUSION;
		else if (IsKeyPressed(KEY_F7)) renderMode = EMISSION;
		else if (IsKeyPressed(KEY_F8)) renderMode = LIGHTING;
		else if (IsKeyPressed(KEY_F9)) renderMode = FRESNEL;
		else if (IsKeyPressed(KEY_F10)) renderMode = IRRADIANCE;
		else if (IsKeyPressed(KEY_F11)) renderMode = REFLECTIVITY;

		// Check for render scale shortcut inputs
		int rs = renderScale;

		if ((GetKeyPressed() == KEY_NUMPAD_SUM) && (renderScale < (MAX_RENDER_SCALES - 1))) rs++;
		else if ((GetKeyPressed() == KEY_NUMPAD_SUBTRACT) && (renderScale > 0)) rs--;
		renderScale = (RenderScale)rs;

		// Check for lights movement input
		if (IsMouseButtonDown(MOUSE_RIGHT_BUTTON))
		{
			// Update mouse delta position
			lastMousePosX = mousePosX;
			mousePosX = GetMouseX();

			// Update lights positions based on delta position with an orbital movement
			lightAngle += (mousePosX - lastMousePosX) * LIGHT_SPEED;
			for (int i = 0; i < totalLights; i++)
			{
				float angle = lightAngle + 90 * i;
				lights[i].position.x = LIGHT_DISTANCE * cosf(angle * DEG2RAD);
				lights[i].position.z = LIGHT_DISTANCE * sinf(angle * DEG2RAD);

				// Send lights values to environment PBR shader
				UpdateLightValues(environment, lights[i]);
			}
		}
		else mousePosX = GetMouseX();

		// Check for interface scrolling
		if (GetMouseWheelMove() != 0 && overUI)
		{
			scrolling += GetMouseWheelMove() * SCROLL_SPEED;
			if (scrolling < -MAX_SCROLL) scrolling = -MAX_SCROLL;
			else if (scrolling > 0) scrolling = 0;
		}

		// Apply camera movement just if movement start is in viewport range
		if (IsMouseButtonPressed(MOUSE_MIDDLE_BUTTON) && overUI) canMoveCamera = false;
		else if (IsMouseButtonReleased(MOUSE_MIDDLE_BUTTON)) canMoveCamera = true;

		// Check for texture map deletion input
		for (int i = 0; i < MAX_TEXTURES; i++)
		{
			// Calculate texture rectangle based on current scrolling and other values
			Vector2 pos = { GetScreenWidth() - UI_MENU_WIDTH + UI_MENU_WIDTH / 2, scrolling + UI_MENU_PADDING * 2 + UI_MENU_PADDING * 2.5f +
							UI_MENU_PADDING * 1.25f + UI_MENU_WIDTH * 0.375f - UI_TEXT_SIZE_H3 / 2 + i * UI_TEXTURES_PADDING };
			Rectangle rect = { pos.x - UI_TEXTURES_SIZE / 2, pos.y - UI_TEXTURES_SIZE / 2, UI_TEXTURES_SIZE, UI_TEXTURES_SIZE };

			// Check if texture map rectangle is pressed
			if (CheckCollisionPointRec(GetMousePosition(), rect) && IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
			{
				UnsetMaterialTexturePBR(&matPBR, (TypePBR)i);
				textures[i] = Texture2D{ 0 };
				break;
			}
		}

		// Avoid conflict between camera zoom and interface scroll
		if (GetMouseWheelMove() != 0) canMoveCamera = !overUI;

		// Fix camera move state if camera mode is orbital and mouse middle button is not down
		if (!canMoveCamera && ((!IsMouseButtonDown(MOUSE_MIDDLE_BUTTON) && (cameraType == CAMERA_ORBITAL)))) canMoveCamera = true;

		/*
		* // Check for light select input
		if (IsMouseButtonPressed(MOUSE_LEFT_BUTTON))
		{
			// Store last selected light value
			int lastSelected = selectedLight;

			// Check mouse-light collision for all lights
			for (int i = 0; i < totalLights; i++)
			{
				Ray ray = GetMouseRay(GetMousePosition(), camera);
				if (CheckCollisionRaySphere(ray, lights[i].position, LIGHT_RADIUS)) selectedLight = i;
			}

			bool currentWindow = false;
			if (selectedLight != -1)
			{
				Vector2 screenPos = GetWorldToScreen(lights[selectedLight].position, camera);
				if (CheckCollisionPointRec(GetMousePosition(), (Rectangle) {
					screenPos.x + UI_MENU_PADDING / 2, screenPos.y +
						UI_MENU_PADDING / 2, UI_LIGHT_WIDTH, UI_LIGHT_HEIGHT
				})) currentWindow = true;
			}

			// Deselect current light if mouse position is not over any light
			if ((selectedLight == lastSelected) && !currentWindow) selectedLight = -1;
		}
		*/

		// Update camera values and send them to all required shaders
		Vector2 screenRes = { (float)GetScreenWidth() * renderScales[renderScale], (float)GetScreenHeight() * renderScales[renderScale] };
		UpdateEnvironmentValues(environment, camera, screenRes);

		// Send resolution values to post-processing shader
		resolution[0] = screenRes.x;
		resolution[1] = screenRes.y;
		SetShaderValue(fxShader, fxResolutionLoc, resolution, SHADER_UNIFORM_VEC2);

		// Send current mode to PBR shader and enabled screen effects states to post-processing shader
		int shaderMode[1] = { renderMode };
		SetShaderValue(environment.pbrShader, shaderModeLoc, shaderMode, SHADER_UNIFORM_INT);
		shaderMode[0] = enabledFxaa;
		SetShaderValue(fxShader, enabledFxaaLoc, shaderMode, SHADER_UNIFORM_INT);
		shaderMode[0] = enabledBloom;
		SetShaderValue(fxShader, enabledBloomLoc, shaderMode, SHADER_UNIFORM_INT);
		shaderMode[0] = enabledVignette;
		SetShaderValue(fxShader, enabledVignetteLoc, shaderMode, SHADER_UNIFORM_INT);

		//--------------------------------------------------------------------------

		// Draw
		//--------------------------------------------------------------------------
		BeginDrawing();

		ClearBackground(DARKGRAY);

		// Render to texture for antialiasing post-processing
		BeginTextureMode(fxTarget);

		BeginMode3D(camera);

		// Draw ground grid
		if (drawGrid) DrawGrid(10, 1.0f);

		// Draw loaded model using physically based rendering
		DrawModelPBR(model, matPBR, Vector3{ 0.0f, 0.0f, 0.0f }, Vector3{ 0.0f, 1.0f, 0.0f }, 0.0f, Vector3{ MODEL_SCALE, MODEL_SCALE, MODEL_SCALE });
		if (drawWire) DrawModelWires(model, Vector3{ 0.0f, 0.0f, 0.0f }, MODEL_SCALE, DARKGRAY);

		// Draw light gizmos
		if (drawLights) for (unsigned int i = 0; (i < totalLights); i++)
		{
			Ray ray = GetMouseRay(GetMousePosition(), camera);

			DrawLight(lights[i], GetRayCollisionSphere(ray, lights[i].position, LIGHT_RADIUS).hit);
		}

		// Render skybox (render as last to prevent overdraw)
		if (drawSkybox) DrawSkybox(environment, camera);

		EndMode3D();

		EndTextureMode();

		BeginShaderMode(fxShader);

		DrawTexturePro(fxTarget.texture, Rectangle{ 0, 0, (float)fxTarget.texture.width, -(float)fxTarget.texture.height },
			Rectangle{
			0, 0, (float)GetScreenWidth(), (float)GetScreenHeight()
			}, Vector2{ 0.0f, 0.0f }, 0.0f, WHITE);

		EndShaderMode();

		// Draw logo if enabled based on interface menu padding
		if (!drawHelp && drawLogo)
		{
			int padding = GetScreenWidth() - UI_MENU_PADDING * 1.25f - iconTex.width;
			if (drawUI) padding -= UI_MENU_WIDTH;
			DrawTexture(iconTex, padding, GetScreenHeight() - UI_MENU_PADDING * 1.25f - iconTex.height, WHITE);
		}

		// Draw help window if help menu is enabled
		if (drawHelp)
		{
			// Draw help background
			DrawRectangle(0, 0, GetScreenWidth(), GetScreenHeight(), Fade(UI_COLOR_BACKGROUND, 0.8f));

			// Draw rPBR logo and title
			int padding = UI_MENU_PADDING * 3 + iconTex.height + UI_MENU_PADDING;
			DrawTexture(iconTex, GetScreenWidth() / 2 - iconTex.width / 2, UI_MENU_PADDING * 3, WHITE);
			DrawText(UI_TEXT_TITLE, GetScreenWidth() / 2 - textsLength[LENGTH_TITLE] / 2, padding, UI_TEXT_SIZE_H3, WHITE);

			// Draw controls title
			padding += UI_MENU_PADDING * 3.5f;
			DrawText(UI_TEXT_CONTROLS, GetScreenWidth() / 2 - textsLength[LENGTH_CONTROLS] / 2, padding, UI_TEXT_SIZE_H1, UI_COLOR_PRIMARY);
			DrawRectangle(GetScreenWidth() / 2 - textsLength[LENGTH_CONTROLS], padding + UI_TEXT_SIZE_H1 + UI_MENU_PADDING / 2, textsLength[LENGTH_CONTROLS] * 2, 2, UI_COLOR_PRIMARY);

			// Draw camera controls labels
			padding += UI_TEXT_SIZE_H1 + UI_MENU_PADDING * 2.5f;
			DrawText(UI_TEXT_CONTROLS_01, GetScreenWidth() * 0.35f, padding, UI_TEXT_SIZE_H2, UI_COLOR_SECONDARY);
			padding += UI_TEXT_SIZE_H2 + UI_MENU_PADDING;
			DrawText(UI_TEXT_CONTROLS_02, GetScreenWidth() * 0.35f, padding, UI_TEXT_SIZE_H2, UI_COLOR_SECONDARY);
			padding += UI_TEXT_SIZE_H2 + UI_MENU_PADDING;
			DrawText(UI_TEXT_CONTROLS_03, GetScreenWidth() * 0.35f, padding, UI_TEXT_SIZE_H2, UI_COLOR_SECONDARY);
			padding += UI_TEXT_SIZE_H2 + UI_MENU_PADDING;
			DrawText(UI_TEXT_CONTROLS_04, GetScreenWidth() * 0.35f, padding, UI_TEXT_SIZE_H2, UI_COLOR_SECONDARY);

			// Draw credits title
			padding += UI_MENU_PADDING * 4;
			DrawText(UI_TEXT_CREDITS, GetScreenWidth() / 2 - textsLength[LENGTH_CREDITS] / 2, padding, UI_TEXT_SIZE_H1, UI_COLOR_PRIMARY);
			DrawRectangle(GetScreenWidth() / 2 - textsLength[LENGTH_CREDITS], padding + UI_TEXT_SIZE_H1 + UI_MENU_PADDING / 2, textsLength[LENGTH_CREDITS] * 2, 2, UI_COLOR_PRIMARY);

			// Draw credits labels
			padding += UI_TEXT_SIZE_H2 + UI_MENU_PADDING * 2.5f;
			DrawText(UI_TEXT_CREDITS_VICTOR, GetScreenWidth() / 2 - textsLength[LENGTH_CREDITS_VICTOR] / 2, padding, UI_TEXT_SIZE_H2, UI_COLOR_SECONDARY);
			padding += UI_TEXT_SIZE_H2 + UI_MENU_PADDING;
			DrawText(UI_TEXT_CREDITS_RAMON, GetScreenWidth() / 2 - textsLength[LENGTH_CREDITS_RAMON] / 2, padding, UI_TEXT_SIZE_H2, UI_COLOR_SECONDARY);
			padding += UI_TEXT_SIZE_H2 + UI_MENU_PADDING * 3;
			DrawText(UI_TEXT_CREDITS_WEB, GetScreenWidth() / 2 - textsLength[LENGTH_CREDITS_WEB] / 2, padding, UI_TEXT_SIZE_H2, UI_COLOR_PRIMARY);

			// Draw close help menu button and check input
			if (GuiButton(Rectangle{
				(float)GetScreenWidth() / 2 - UI_BUTTON_WIDTH / 2, (float)GetScreenHeight() - UI_BUTTON_HEIGHT - UI_MENU_PADDING * 5,
					UI_BUTTON_WIDTH, UI_BUTTON_HEIGHT
				}, UI_TEXT_BUTTON_CLOSE_HELP)) drawHelp = false;
		}
		else if (drawUI)
		{
			// Draw light settings interface if any light is selected
			if (selectedLight != -1) DrawLightInterface(&lights[selectedLight]);

			// Draw global interface to manage textures, material properties and render settings
			DrawInterface(Vector2{ (float)GetScreenWidth(), (float)GetScreenHeight() }, scrolling);
		}

		EndDrawing();

		//--------------------------------------------------------------------------
	}

	// De-Initialization
	//------------------------------------------------------------------------------
	// Clear internal buffers

	// Unload loaded model mesh and binded textures
	UnloadModel(model);

	// Unload materialPBR assigned textures
	UnloadMaterialPBR(matPBR);

	// Unload environment loaded shaders and dynamic textures
	UnloadEnvironment(environment);

	// Unload other resources
	UnloadImage(icon);
	UnloadTexture(iconTex);
	UnloadRenderTexture(fxTarget);
	UnloadShader(fxShader);

	// Close window and OpenGL context
	CloseWindow();

	//------------------------------------------------------------------------------

	return 0;
}

//----------------------------------------------------------------------------------
// Function Declarations
//----------------------------------------------------------------------------------
// Initialize interface texts lengths
void InitInterface(void)
{
	// Load GUI style
	GuiLoadStyle(PATH_GUI_STYLE);

	// Calculate interface right menu titles lengths
	textsLength[LENGTH_TEXTURES_TITLE] = MeasureText(UI_TEXT_TEXTURES_TITLE, UI_TEXT_SIZE_H2);
	titlesLength[0] = MeasureText(textureTitles[0], UI_TEXT_SIZE_H3);
	titlesLength[1] = MeasureText(textureTitles[1], UI_TEXT_SIZE_H3);
	titlesLength[2] = MeasureText(textureTitles[2], UI_TEXT_SIZE_H3);
	titlesLength[3] = MeasureText(textureTitles[3], UI_TEXT_SIZE_H3);
	titlesLength[4] = MeasureText(textureTitles[4], UI_TEXT_SIZE_H3);
	titlesLength[5] = MeasureText(textureTitles[5], UI_TEXT_SIZE_H3);
	titlesLength[6] = MeasureText(textureTitles[6], UI_TEXT_SIZE_H3);

	// Calculate interface left menu titles lengths
	textsLength[LENGTH_MATERIAL_TITLE] = MeasureText(UI_TEXT_MATERIAL_TITLE, UI_TEXT_SIZE_H2);
	textsLength[LENGTH_RENDER_TITLE] = MeasureText(UI_TEXT_RENDER_TITLE, UI_TEXT_SIZE_H2);
	textsLength[LENGTH_RENDER_SCALE] = MeasureText(UI_TEXT_RENDER_SCALE, UI_TEXT_SIZE_H3);
	textsLength[LENGTH_RENDER_MODE] = MeasureText(UI_TEXT_RENDER_MODE, UI_TEXT_SIZE_H3);
	textsLength[LENGTH_RENDER_EFFECTS] = MeasureText(UI_TEXT_RENDER_EFFECTS, UI_TEXT_SIZE_H3);
	textsLength[LENGTH_EFFECTS_TITLE] = MeasureText(UI_TEXT_EFFECTS_TITLE, UI_TEXT_SIZE_H2);
	textsLength[LENGTH_CONTROLS] = MeasureText(UI_TEXT_CONTROLS, UI_TEXT_SIZE_H1);
	textsLength[LENGTH_TITLE] = MeasureText(UI_TEXT_TITLE, UI_TEXT_SIZE_H3);
	textsLength[LENGTH_CREDITS] = MeasureText(UI_TEXT_CREDITS, UI_TEXT_SIZE_H1);
	textsLength[LENGTH_CREDITS_VICTOR] = MeasureText(UI_TEXT_CREDITS_VICTOR, UI_TEXT_SIZE_H2);
	textsLength[LENGTH_CREDITS_RAMON] = MeasureText(UI_TEXT_CREDITS_RAMON, UI_TEXT_SIZE_H2);
	textsLength[LENGTH_CREDITS_WEB] = MeasureText(UI_TEXT_CREDITS_WEB, UI_TEXT_SIZE_H2);
	textsLength[LENGTH_DRAG] = MeasureText(UI_TEXT_DRAG_HERE, UI_TEXT_SIZE_H3);
	textsLength[LENGTH_DELETE] = MeasureText(UI_TEXT_DELETE, UI_TEXT_SIZE_H3);
	textsLength[LENGTH_DISPLAY] = MeasureText(UI_TEXT_DISPLAY, UI_TEXT_SIZE_H3);
}

// Draw a light gizmo based on light attributes
void DrawLight(Light light, bool over)
{
	switch (light.type)
	{
	case LIGHT_DIRECTIONAL:
	{
		DrawSphere(light.position, (over ? (LIGHT_RADIUS + LIGHT_OFFSET) : LIGHT_RADIUS), (light.enabled ? light.color : GRAY));
		DrawLine3D(light.position, light.target, (light.enabled ? light.color : DARKGRAY));
		DrawCircle3D(light.target, LIGHT_RADIUS, Vector3{ 1.0f, 0.0f, 0.0f }, 90.0f, (light.enabled ? light.color : GRAY));
		DrawCircle3D(light.target, LIGHT_RADIUS, Vector3{ 0.0f, 1.0f, 0.0f }, 90.0f, (light.enabled ? light.color : GRAY));
		DrawCircle3D(light.target, LIGHT_RADIUS, Vector3{ 0.0f, 0.0f, 1.0f }, 90.0f, (light.enabled ? light.color : GRAY));
	} break;
	case LIGHT_POINT: DrawSphere(light.position, (over ? (LIGHT_RADIUS + LIGHT_OFFSET) : LIGHT_RADIUS), (light.enabled ? light.color : GRAY));
	default: break;
	}
}

// Draw interface based on current window dimensions
void DrawInterface(Vector2 size, int scrolling)
{
	// TODO: draw new interface style

	int padding = scrolling;

	// Draw interface right menu background
	DrawRectangle(size.x - UI_MENU_WIDTH, 0, UI_MENU_WIDTH, size.y, UI_COLOR_BACKGROUND);
	DrawRectangle(size.x - UI_MENU_WIDTH - UI_MENU_BORDER, 0, UI_MENU_BORDER, size.y, UI_COLOR_PRIMARY);

	// Draw textures title
	DrawText(UI_TEXT_TEXTURES_TITLE, size.x - UI_MENU_WIDTH + UI_MENU_WIDTH / 2 - textsLength[LENGTH_TEXTURES_TITLE] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H2, UI_COLOR_PRIMARY);
	DrawRectangle(size.x - UI_MENU_WIDTH + UI_MENU_WIDTH / 2 - textsLength[LENGTH_TEXTURES_TITLE] / 2, padding + UI_MENU_PADDING * 2.4f, textsLength[LENGTH_TEXTURES_TITLE], 2, UI_COLOR_PRIMARY);

	// Draw textures
	padding = scrolling + UI_MENU_PADDING * 2 + UI_MENU_PADDING * 2.5f + UI_MENU_PADDING * 1.25f;
	for (int i = 0; i < MAX_TEXTURES; i++)
	{
		Vector2 pos = { size.x - UI_MENU_WIDTH + UI_MENU_WIDTH / 2, padding + UI_MENU_WIDTH * 0.375f - UI_TEXT_SIZE_H3 / 2 + i * UI_TEXTURES_PADDING };
		DrawTextureMap(i, textures[i], pos);
	}

	/*	// Reset padding to start with left menu drawing
		padding = 0;

		// Draw interface left menu background
		DrawRectangle(0, 0, UI_MENU_WIDTH, size.y, UI_COLOR_BACKGROUND);
		DrawRectangle(UI_MENU_WIDTH - UI_MENU_BORDER, 0, UI_MENU_BORDER, size.y, UI_COLOR_PRIMARY);

		// Draw material title
		DrawText(UI_TEXT_MATERIAL_TITLE, UI_MENU_WIDTH / 2 - textsLength[LENGTH_MATERIAL_TITLE] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H2, UI_COLOR_PRIMARY);
		DrawRectangle(UI_MENU_WIDTH / 2 - textsLength[LENGTH_MATERIAL_TITLE] / 2, padding + UI_MENU_PADDING * 2.4f, textsLength[LENGTH_MATERIAL_TITLE], 2, UI_COLOR_PRIMARY);

		// Draw albedo RGB sliders
		padding += UI_MENU_PADDING * 2.5f;
		DrawText(textureTitles[0], UI_MENU_WIDTH / 2 - titlesLength[0] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H3, UI_COLOR_PRIMARY);
		padding += UI_MENU_PADDING * 2.25f;
		DrawText("R", UI_MENU_WIDTH / 10 - UI_TEXT_SIZE_H3 / 2, padding + UI_MENU_BORDER, UI_TEXT_SIZE_H3, UI_COLOR_SECONDARY);
		matPBR.albedo.color.r = (int)GuiSlider(Rectangle{
			UI_MENU_BORDER * 2 + UI_MENU_WIDTH / 2 - UI_MENU_WIDTH * 0.75f / 2,
				(float)padding, UI_MENU_WIDTH * 0.75f, UI_SLIDER_HEIGHT
			}, matPBR.albedo.color.r, 0, 255);
		padding += UI_MENU_PADDING * 2;
		DrawText("G", UI_MENU_WIDTH / 10 - UI_TEXT_SIZE_H3 / 2, padding + UI_MENU_BORDER, UI_TEXT_SIZE_H3, UI_COLOR_SECONDARY);
		matPBR.albedo.color.g = (int)GuiSlider((Rectangle) {
			UI_MENU_BORDER * 2 + UI_MENU_WIDTH / 2 - UI_MENU_WIDTH * 0.75f / 2,
				padding, UI_MENU_WIDTH * 0.75f, UI_SLIDER_HEIGHT
		}, matPBR.albedo.color.g, 0, 255);
		padding += UI_MENU_PADDING * 2;
		DrawText("B", UI_MENU_WIDTH / 10 - UI_TEXT_SIZE_H3 / 2, padding + UI_MENU_BORDER, UI_TEXT_SIZE_H3, UI_COLOR_SECONDARY);
		matPBR.albedo.color.b = (int)GuiSlider((Rectangle) {
			UI_MENU_BORDER * 2 + UI_MENU_WIDTH / 2 - UI_MENU_WIDTH * 0.75f / 2,
				padding, UI_MENU_WIDTH * 0.75f, UI_SLIDER_HEIGHT
		}, matPBR.albedo.color.b, 0, 255);

		// Draw metalness slider
		padding += UI_MENU_PADDING * 2;
		DrawText(textureTitles[2], UI_MENU_WIDTH / 2 - titlesLength[2] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H3, UI_COLOR_PRIMARY);
		padding += UI_MENU_PADDING * 2.25f;
		matPBR.metalness.color.r = (int)GuiSlider((Rectangle) { UI_MENU_WIDTH / 2 - UI_MENU_WIDTH * 0.75f / 2, padding, UI_MENU_WIDTH * 0.75f, UI_SLIDER_HEIGHT }, matPBR.metalness.color.r, 0, 255);

		// Draw roughness slider
		padding += UI_MENU_PADDING * 2;
		DrawText(textureTitles[3], UI_MENU_WIDTH / 2 - titlesLength[3] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H3, UI_COLOR_PRIMARY);
		padding += UI_MENU_PADDING * 2.25f;
		matPBR.roughness.color.r = (int)GuiSlider((Rectangle) { UI_MENU_WIDTH / 2 - UI_MENU_WIDTH * 0.75f / 2, padding, UI_MENU_WIDTH * 0.75f, UI_SLIDER_HEIGHT }, matPBR.roughness.color.r, 0, 255);

		// Draw height parallax slider
		padding += UI_MENU_PADDING * 2;
		DrawText(textureTitles[6], UI_MENU_WIDTH / 2 - titlesLength[6] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H3, UI_COLOR_PRIMARY);
		padding += UI_MENU_PADDING * 2.25f;
		matPBR.height.color.r = (int)GuiSlider((Rectangle) { UI_MENU_WIDTH / 2 - UI_MENU_WIDTH * 0.75f / 2, padding, UI_MENU_WIDTH * 0.75f, UI_SLIDER_HEIGHT }, matPBR.height.color.r, 0, 255);

		// Draw render settings title
		padding += UI_MENU_PADDING * 2.5f;
		DrawText(UI_TEXT_RENDER_TITLE, UI_MENU_WIDTH / 2 - textsLength[LENGTH_RENDER_TITLE] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H2, UI_COLOR_PRIMARY);
		DrawRectangle(UI_MENU_WIDTH / 2 - textsLength[LENGTH_RENDER_TITLE] / 2, padding + UI_MENU_PADDING * 2.4f, textsLength[LENGTH_RENDER_TITLE], 2, UI_COLOR_PRIMARY);

		// Draw render scale combo box
		padding += UI_MENU_PADDING * 2.5f;
		DrawText(UI_TEXT_RENDER_SCALE, UI_MENU_WIDTH / 2 - textsLength[LENGTH_RENDER_SCALE] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H3, UI_COLOR_PRIMARY);
		padding += UI_MENU_PADDING * 2.25f;
		renderScale = (RenderScale)GuiComboBox(Rectangle{ UI_MENU_WIDTH / 2 - UI_MENU_WIDTH * 0.3f - UI_MENU_WIDTH * 0.6f / 8, (float)padding, UI_MENU_WIDTH * 0.6f, UI_SLIDER_HEIGHT * 1.5f }, *renderScalesTitles, (int*)renderScale);

		// Draw render mode combo box
		padding += UI_MENU_PADDING * 2.0f;
		DrawText(UI_TEXT_RENDER_MODE, UI_MENU_WIDTH / 2 - textsLength[LENGTH_RENDER_MODE] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H3, UI_COLOR_PRIMARY);
		padding += UI_MENU_PADDING * 2.25f;
		renderMode = (RenderMode)GuiComboBox(Rectangle{ UI_MENU_WIDTH / 2 - UI_MENU_WIDTH * 0.3f - UI_MENU_WIDTH * 0.6f / 8, (float)padding, UI_MENU_WIDTH * 0.6f, UI_SLIDER_HEIGHT * 1.5f }, *renderModesTitles, (int*)renderMode);

		// Draw post-processing effects title
		padding += UI_MENU_PADDING * 3;
		DrawText(UI_TEXT_EFFECTS_TITLE, UI_MENU_WIDTH / 2 - textsLength[LENGTH_EFFECTS_TITLE] / 2, padding + UI_MENU_PADDING, UI_TEXT_SIZE_H2, UI_COLOR_PRIMARY);
		DrawRectangle(UI_MENU_WIDTH / 2 - textsLength[LENGTH_RENDER_TITLE] / 2, padding + UI_MENU_PADDING * 2.4f, textsLength[LENGTH_RENDER_TITLE], 2, UI_COLOR_PRIMARY);

		// Draw FXAA effect enabled state checkbox
		padding += UI_MENU_PADDING * 3.75f;
		enabledFxaa = GuiCheckBox(Rectangle{ UI_MENU_PADDING * 1.85f,(float)padding, UI_CHECKBOX_SIZE, UI_CHECKBOX_SIZE }, UI_TEXT_EFFECTS_FXAA, &enabledFxaa);

		// Draw bloom effect enabled state checkbox
		padding += UI_MENU_PADDING * 2.0f;
		enabledBloom = GuiCheckBox(Rectangle{ UI_MENU_PADDING * 1.85f, (float)padding, UI_CHECKBOX_SIZE, UI_CHECKBOX_SIZE }, UI_TEXT_EFFECTS_BLOOM, &enabledBloom);

		// Draw vignette effect enabled state checkbox
		padding += UI_MENU_PADDING * 2.0f;
		enabledVignette = GuiCheckBox(Rectangle{ UI_MENU_PADDING * 1.85f, (float)padding, UI_CHECKBOX_SIZE, UI_CHECKBOX_SIZE }, UI_TEXT_EFFECTS_VIGNETTE, &enabledVignette);

		// Draw wireframe effect enabled state checkbox
		padding += UI_MENU_PADDING * 2.0f;
		drawWire = GuiCheckBox(Rectangle{ UI_MENU_PADDING * 1.85f, (float)padding, UI_CHECKBOX_SIZE, UI_CHECKBOX_SIZE }, UI_TEXT_EFFECTS_WIRE, &drawWire);

		// Draw draw logo enabled state checkbox
		padding += UI_MENU_PADDING * 2.0f;
		drawLogo = GuiCheckBox(Rectangle{ UI_MENU_PADDING * 1.85f, (float)padding, UI_CHECKBOX_SIZE, UI_CHECKBOX_SIZE }, UI_TEXT_DRAW_LOGO, &drawLogo);

		// Draw draw lights enabled state checkbox
		padding += UI_MENU_PADDING * 2.0f;
		drawLights = GuiCheckBox(Rectangle{ UI_MENU_PADDING * 1.85f, (float)padding, UI_CHECKBOX_SIZE, UI_CHECKBOX_SIZE }, UI_TEXT_DRAW_LIGHTS, &drawLights);

		// Draw draw grid enabled state checkbox
		padding += UI_MENU_PADDING * 2.0f;
		drawGrid = GuiCheckBox(Rectangle{ UI_MENU_PADDING * 1.85f, (float)padding, UI_CHECKBOX_SIZE, UI_CHECKBOX_SIZE }, UI_TEXT_DRAW_GRID, &drawGrid);

		// Draw viewport interface help button
		if (GuiButton((Rectangle) { UI_MENU_WIDTH + UI_MENU_PADDING, GetScreenHeight() - UI_MENU_PADDING - UI_BUTTON_HEIGHT, UI_BUTTON_WIDTH, UI_BUTTON_HEIGHT }, UI_TEXT_BUTTON_HELP))
		{
			drawHelp = true;
			if (selectedLight != -1) selectedLight = -1;
		}

		// Draw viewport interface screenshot button
		padding = UI_MENU_WIDTH + UI_MENU_PADDING + UI_BUTTON_WIDTH + UI_MENU_PADDING;
		if (GuiButton(Rectangle{ (float)padding, (float)GetScreenHeight() - UI_MENU_PADDING - UI_BUTTON_HEIGHT, UI_BUTTON_WIDTH, UI_BUTTON_HEIGHT }, UI_TEXT_BUTTON_SS))
		{
			TakeScreenshot(TextFormat("rpbr_screenshot_%i.png", screenShotCount));
			screenShotCount++;
		}

		// Draw viewport interface camera type combo box
		padding += UI_BUTTON_WIDTH + UI_MENU_PADDING;
		cameraType = (CameraType)GuiComboBox(Rectangle{
			(float)padding, (float)GetScreenHeight() - UI_MENU_PADDING - UI_BUTTON_HEIGHT,
				UI_BUTTON_WIDTH, UI_BUTTON_HEIGHT
			}, (const char*)MAX_CAMERA_TYPES, (int*)cameraTypesTitles);

		// Draw viewport interface reset scene button
		padding += UI_MENU_PADDING * 2 + UI_BUTTON_WIDTH + UI_MENU_PADDING;
		if (GuiButton(Rectangle{ (float)padding, (float)GetScreenHeight() - UI_MENU_PADDING - UI_BUTTON_HEIGHT, UI_BUTTON_WIDTH, UI_BUTTON_HEIGHT }, UI_TEXT_BUTTON_RESET)) resetScene = true;

		// Draw viewport interface display/hide help message
		DrawText(UI_TEXT_DISPLAY, GetScreenWidth() - UI_MENU_WIDTH - textsLength[LENGTH_DISPLAY] - 10, GetScreenHeight() - UI_TEXT_SIZE_H3 - 5, UI_TEXT_SIZE_H3, UI_COLOR_BACKGROUND);

	*/

	// Update metalness and roughness unused color values
	matPBR.metalness.color.g = matPBR.metalness.color.r;
	matPBR.metalness.color.b = matPBR.metalness.color.r;
	matPBR.roughness.color.g = matPBR.roughness.color.r;
	matPBR.roughness.color.b = matPBR.roughness.color.r;
}

// Draw specific light settings interface
void DrawLightInterface(Light* light)
{
	Vector2 screenPos = GetWorldToScreen(light->position, camera);
	Vector2 padding = { screenPos.x + UI_MENU_PADDING / 2, screenPos.y + UI_MENU_PADDING / 2 };

	// Draw interface background
	DrawRectangle(padding.x, padding.y, UI_LIGHT_WIDTH, UI_LIGHT_HEIGHT, UI_COLOR_PRIMARY);
	DrawRectangle(padding.x + 3, padding.y + 3, UI_LIGHT_WIDTH - 6, UI_LIGHT_HEIGHT - 6, UI_COLOR_BACKGROUND);
	padding.x += UI_MENU_PADDING;
	padding.y += UI_MENU_PADDING;

	// Draw light enabled state checkboxgit
	light->enabled = GuiCheckBox(Rectangle{ padding.x, padding.y, UI_CHECKBOX_SIZE, UI_CHECKBOX_SIZE }, "enabled", &light->enabled);
	padding.y += UI_MENU_PADDING * 2;

	// Draw light color R channel slider
	light->color.r = (int)GuiSlider(Rectangle{ padding.x + UI_MENU_PADDING * 1.5f, padding.y, UI_LIGHT_WIDTH * 0.75f, UI_SLIDER_HEIGHT }, "min", "max", (float*)light->color.r, 0, 255);
	DrawText(UI_TEXT_LIGHT_R, padding.x, padding.y + UI_TEXT_SIZE_H3 / 2, UI_TEXT_SIZE_H3, UI_COLOR_SECONDARY);
	padding.y += UI_MENU_PADDING * 2;

	// Draw light color G channel slider
	light->color.g = (int)GuiSlider(Rectangle{ padding.x + UI_MENU_PADDING * 1.5f, padding.y, UI_LIGHT_WIDTH * 0.75f, UI_SLIDER_HEIGHT }, "min", "max", (float*)light->color.g, 0, 255);
	DrawText(UI_TEXT_LIGHT_G, padding.x, padding.y + UI_TEXT_SIZE_H3 / 2, UI_TEXT_SIZE_H3, UI_COLOR_SECONDARY);
	padding.y += UI_MENU_PADDING * 2;

	// Draw light color B channel slider
	light->color.b = (int)GuiSlider(Rectangle{ padding.x + UI_MENU_PADDING * 1.5f, padding.y, UI_LIGHT_WIDTH * 0.75f, UI_SLIDER_HEIGHT }, "min", "max", (float*)light->color.b, 0, 255);
	DrawText(UI_TEXT_LIGHT_B, padding.x, padding.y + UI_TEXT_SIZE_H3 / 2, UI_TEXT_SIZE_H3, UI_COLOR_SECONDARY);
	padding.y += UI_MENU_PADDING * 2;

	// Send lights values to environment PBR shader
	UpdateLightValues(environment, *light);
}

// Draw interface PBR texture or alternative text
void DrawTextureMap(int id, Texture2D texture, Vector2 position)
{
	Rectangle rect = { position.x - UI_TEXTURES_SIZE / 2, position.y - UI_TEXTURES_SIZE / 2, UI_TEXTURES_SIZE, UI_TEXTURES_SIZE };
	DrawRectangle(rect.x - UI_MENU_BORDER, rect.y - UI_MENU_BORDER, rect.width + UI_MENU_BORDER * 2, rect.height + UI_MENU_BORDER * 2, UI_COLOR_PRIMARY);
	DrawText(textureTitles[id], position.x - titlesLength[id] / 2, position.y - UI_TEXT_SIZE_H3 / 2 - rect.height * 0.6f, UI_TEXT_SIZE_H3, UI_COLOR_PRIMARY);

	// Draw PBR texture or display help message
	if (texture.id != 0)
	{
		DrawTexturePro(texture, Rectangle{ 0, 0, (float)texture.width, (float)texture.height }, rect, Vector2{ 0.0f, 0.0f }, 0.0f, WHITE);

		// Draw semi-transparent rectangle if mouse is over the texture rectangle
		if (CheckCollisionPointRec(GetMousePosition(), rect))
		{
			DrawRectangleRec(rect, Fade(UI_COLOR_SECONDARY, 0.5f));
			DrawText(UI_TEXT_DELETE, rect.x + rect.width / 2 - textsLength[LENGTH_DELETE] / 2, rect.y + rect.height / 2 - UI_TEXT_SIZE_H3 / 2, UI_TEXT_SIZE_H3, UI_COLOR_BACKGROUND);
		}
	}
	else
	{
		DrawRectangleRec(rect, UI_COLOR_SECONDARY);
		DrawText(UI_TEXT_DRAG_HERE, position.x - textsLength[LENGTH_DRAG] / 2, position.y, UI_TEXT_SIZE_H3, UI_COLOR_PRIMARY);
	}
}
